1. 从“在浏览器输入域名”到“页面静态资源完全加载”的整个流程
    整个过程可以分为几步：
    1. 用户输入

    当用户输入关键字并键入回车之后，这意味着当前页面将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行beforeunload事件的机会，beforeunload事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否离开当前页面

    2. url请求过程
    
   ######  首先，网络进程会查找本地缓存是否缓存了该资源。 缓存？？？
    
    ******************************************************
    缓存位置： 
    - Service Worker 运行于浏览器背后的独立线程，传输协议必须为https，与浏览器其他内建的缓存机制不同，他可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续的
    - Memory Cache也就是内存中的缓存，主要包含的是当前页面中已经抓取到的资源例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭tab页面，内存中的缓存也就被释放了。内存缓存中有一块重要的缓存资源是preloader相关指令，例如<link rel="prefetch">下载的资源，preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css，一边网络请求下一下资源。 内存缓存在缓存资源时并不关心资源的HTTP缓存头cache-control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type,CORS等其他特征做校验。
    - Disk Cache 也就是存储在硬盘中的缓存，速度慢但是容量大，在所有浏览器缓存中Disk Cache覆盖面基本最大。它会根据HTTP header中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，那些资源已经过期需要重新请求，并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据，绝大多数的缓存都来自于Disk Cache.
    - Push Cache（推送缓存）是HTTP/2的内容，当以上三种缓存都没有命中时，它才会被使用。它只在session中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在chorme中浏览器中只有5分钟左右，同时它也并非严格执行http头中的缓存指令。

    通常浏览器缓存分为两种：强缓存和协商缓存，并且缓存策略都是通过设置Http header来实现的
    浏览器对于缓存的处理是根据第一次请求资源时返回的**响应头**来确定的。
    浏览器每次发起请求，都会先在浏览器缓存中查找该请求的缓存结果和缓存标识
    浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入到浏览器缓存中

    - 基本原理
        1. 浏览器在加载资源的时候会根据请求头的expires和cache-control判断是否命中强缓存，如果是则直接从缓存中读取资源，不会向服务器发送请求，并且chorme network选项可以看到该请求返回200状态码，并且size显示from disk cache或from memory cache
            - expires 缓存过期时间，用来指定资源过期的时间，描述的是一个绝对时间，由服务器返回，受限于本地实际，如果修改了本地时间可能会造成缓存失效
            - cache-control出现于http1.1优先级高于expires表示的是相对时间，cache-control:max-age=31535000 
            - no-cache不会缓存数据到本地的说法是错误的缓存但立即失效，下次发起请求验证资源是否过期，no-store才是真正的不缓存数据到本地，public可以被所有用户护岸村包括客户端和中间代理服务器，private只能被终端浏览器护岸村
            - no-cache 是否使用缓存需要经过协商缓存来验证决定表示不适用cache-control的缓存控制方式来做前置校验，而是使用etag和last-modified字段来控制缓存，不是说浏览器不再缓存而是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致
        2. 如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过last-modified和etag验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回但是不会返回这个资源的数据，依然是从缓存中读取数据
        协商缓存就是强缓存失效之后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存
        
        - 协商缓存生效，返回304和Not Modified
        - 协商缓存失效，返回200和请求结果

        - last-modified和if-modified-since
          浏览器第一次访问资源时，服务器返回资源的同时，在response header中添加last-modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header
          浏览器下一次请求这个资源，检测到有last-modified这个header，于是添加if-modified-since这个header请求头，值为上次返回的last-modified的值，服务器接收请求，判断if-modified-since的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空响应体，直接从缓存中读取，如果值小于服务器资源的更新时间，说明文件更新，返回新的资源文件和200
            - 弊端：
            1. 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成last-modified被修改，服务端不能命中缓存导致发送相同资源 
            2. last-modified只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端还是会认为资源被命中了，不能返回正确的资源
        - etag和if-none-match
            - etag是服务器响应请求时，返回当前资源文件的一个唯一标识（服务器生成）只要资源有变化，etag就会重新生成，浏览器在下一次加载资源时候发送请求，会将上一次返回的etag的值放到请求头的if-none-match里，服务器只需要比较客户端传过来的if-none-match跟自己服务器上该资源的etag是否一致就能很好地判断资源相对客户端而言是否修改过了。如果etag与if-none-match匹配不上，那么就会返回新资源和200，如果一致，返回304通知客户端使用本地缓存即可
        - etag和if-none-match优先级高于last-modified和if-modified-since

        3. 如果都没有命中，直接从服务器加载资源


        4. 如果什么缓存策略都没设置，那么浏览器会怎么处理
        对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的date减去last-modified值的10%作为缓存时间

        使用场景
        1. 频繁变动的资源 cache-control：no-cache
        对于频繁变动的资源，首先需要使用Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。

        2. 不常变动的资源 Cache-Control: max-age=31536000，如果要更新，在文件名中添加hash版本号等，从而更改url，让之前的强制缓存失效


        用户行为对浏览器缓存的影响
        1. 打开网页，地址栏输入网址：查找disk cache中是否有匹配，如有则使用，如没有则发送网络请求
        2. 普通刷新，因为tab没有关闭，因此memory cache是可用的会被有限使用（如果匹配的话）。其次才是disk cache
        3. 强制刷新 浏览器不适用缓存，因此发送的请求头部均带有cache-control：no-store 为了兼容还带了Pragma:no-cache,服务器直接返回200和最新内容

    ******************************************************
   


    ###### 如果有缓存资源，那么直接返回资源给浏览器进程，如果在缓存中没有查找到资源，那么直接进入网络请求流程。这请求前的第一步是要进行DNS解析，以获取请求域名的服务器IP地址。如果请求协议是HTTPS，那么还需要建立TLS连接。 DNS解析过程？？？ HTTPS？

    *******************************************************
    - 前端优化点：DNS解析：一是减少DNS的请求次数，二是进行DNS预获取
    - 浏览器对网站第一次域名DNS解析查找流程依次为：
      浏览器缓存-》系统缓存hosts文件-》本地DNS解析-》路由器缓存-》ISP DNS缓存 -》递归搜索
      - DNS预解析是浏览器试图在用户访问链接之前解析域名，域名解析后，如果用户确实访问该域名，那么DNS解析时间将不会有延迟。遇到网页中的超链接，DNS prefetch从中提取域名并将其解析为ip地址
    

    - TLS连接
      
    *******************************************************

    ###### 接下来是利用IP地址和服务器建立TCP连接。连接建立之后，浏览器会构建请求行、请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，然后向服务器发送构建的请求信息。 TCP链接？？？ 请求头？？？

    ###### 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个HTML文件。


   ######  首先浏览器会判断状态码是什么，如果是200那就继续解析，如果是400或500的话就会报错，如果是300的话就会重定向，这里会有个重定向计数器，避免多次的重定向，超过次数也会报错。 状态码？？？重定向？？？

   ###### 浏览器开始解析文件，如果是gzip格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件。 gzip
    - 其中，DNS也有几步缓存：浏览器缓存，hosts文件？？
    - 如果本地域名解析服务器也没有该域名的记录，则开始递归+迭代解析
    - TCP三次握手，HTTP？TLS握手？？？HTTPS？

    1. 准备渲染进程
    
    默认情况下，Chorme会为每个页面分配一个渲染进程。也就是说，每打开一个新页面就会配套创建一个新的渲染进程。

    1. 渲染阶段

    文字解码成功之后会正式开始渲染流程，会先根据HTML构建DOM树，有css的话会去构建CSSOM树，如果遇到script标签的话，会判断是否存在async或defer，async会并行进行下载并执行js，defer会先下载文件，然后等待HTML解析完成后顺序执行

    如果以上都没有，就会阻塞住渲染流程直到js执行完毕

    CSSOM树和DOM树构建完成之后会开始生成Render树，这一步就是确定页面元素的布局，样式等等多方面的东西。

    在生成Render树的过程中，浏览器就开始调用GPU绘制，合成图层，将内容显示在屏幕上了。

