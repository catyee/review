<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // function deepClone(target) {
        //     let newObj = {}
        //     if(target === null) return target
        //     if(typeof target !== 'object') return target
        //     for(let i in target) {
        //         newObj[i] = deepClone(target[i])
        //     }
        //     return newObj
        // }
        function deepClone(target) {
        const map = new Map()
        function clone() {
            if(target === null || typeof target !== 'object') {
            return target
            }
            var result = Array.isArray(target) ? [] : {}
            if(map.get(target)) {
                return map.get(target)
            }

            map.set(target, result)
            for(let key in target) {
                if(target.hasOwnProperty(key)) {
                    result[key] = clone(result[key])
                
                }
            }
        return result
      }
       return clone(target)
     }

     function deepClone3(target) {
    const map = new WeakMap()
        function clone (target) {
            if (target!== null && typeof target === 'object') {
                let cloneTarget = Array.isArray(target) ? [] : {};
                if (map.get(target)) {
                    console.log(map.get(target),'ggggggggggggggg')
                    return map.get(target)
                }
                map.set(target,cloneTarget)
                for (const key in target) {
                    cloneTarget[key] = clone(target[key]);
                }
                return cloneTarget;
            } else {
                return target;
            }
        }
        return clone(target)
};
function deepClone1(obj, hash = new WeakMap()) {
    console.log(hash,'ssssssssssssss')
  if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝
  if (typeof obj !== "object") return obj;
  console.log(hash.get(obj),obj,hash,8888888888)
  // 是对象的话就要进行深拷贝
  if (hash.get(obj)) {
    console.log('bbbbbbbbbbbbbbbbbbbb')
    return hash.get(obj);
  }
  let cloneObj = new obj.constructor();
  console.log(cloneObj, 'oooooooooooo')
  // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身
  hash.set(obj, cloneObj);
  //console.log(hash, 'hhhhhhhhhhhhhh')
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      // 实现一个递归拷贝
      cloneObj[key] = deepClone(obj[key], hash);
    }
  }
  return cloneObj;
}
        let obj = {
            name: 'zhufeng',
            age: 12,
            boo: true,
            n: null,
            m: undefined,
            sy: Symbol('xx'),
            big: 10n,
            child: {
                ele: 'body',
                x: 100
            },
            arr: [10, 20, 30],
            reg: /^\d+$/,
            fn: function () {
                console.log(this.name);
            },
            time: new Date(),
            err: new Error()
        };
        obj.target = obj
        var newObj = deepClone1(obj)
        var newObj1 = deepClone3(obj)
        console.log(newObj,33333333333333,newObj1)
    </script>
</body>
</html>