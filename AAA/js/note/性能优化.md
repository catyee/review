# 1. prefetch 和 preload

## preload和prefetch不会阻塞页面的onload。
## preload用来声明当前页面的关键资源，强制浏览器尽快加载；而prefetch用来声明将来可能用到的资源，在浏览器空闲时进行加载。


## preload的字体资源必须设置crossorigin属性，否则会导致重复加载。 
原因是如果不指定crossorigin属性(即使同源)，浏览器会采用匿名模式的CORS去preload，导致两次请求无法共用缓存。





## 可以使用webpack插件 preload-webpack-plugin 自动将资源以preload方式预加载 在构建过程中插入link标签
 <link rel="preload" as="font" href="<%= require('/assets/fonts/AvenirNextLTPro-Demi.otf') %>" crossorigin>
<link rel="preload" as="font" href="<%= require('/assets/fonts/AvenirNextLTPro-Regular.otf') %>" crossorigin>

## preload的设计初衷就是为了尽早加载首屏需要的关键资源，从而提升页面渲染
目前的浏览器基本上都具备预测解析能力，可以提前解析入口html外链的资源，因此入口脚本文件，样式文件等不需要特意进行preload

但是一些隐藏在css和js中的资源，比如字体文件，本身是首屏加载的关键资源，但是当css解析完成之后才会被浏览器加载，这种场景适合使用preload进行声明，尽早进行资源加载，避免页面渲染延迟。

## prefetch 声明的是将来可能访问的资源，因此适合对异步加载的模块、可能跳转到的其他路由页面进行资源缓存，对于一些将来大概率会访问的资源，如背景图，常见的加载失败icon等，也较为适用

## 最佳实践
- 大部分场景下无需特意使用preload
- 类似字体文件这种隐藏在脚本、样式中的首屏关键资源，建议使用preload
- 异步加载的模块（典型的如单页系统中的非首页）建议使用prefetch
- 大概率即将被访问到的资源可以使用prefetch提升性能和体验