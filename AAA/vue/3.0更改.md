# 全局api
vue2.0有许多全局api和配置，这些api和配置可以全局改变vue的行为。例如，要注册全局组件，可以使用Vue.component这样的API
Vue.component('button-counter', {
  data: () => ({
    count: 0
  }),
  template: '<button @click="count++">Clicked {{ count }} times.</button>'
})
类似地，使用全局指令的声明方式如下：

Vue.directive('focus', {
  inserted: el => el.focus()
})

虽然这种声明方式很方便，但它会导致一些问题，从技术上讲，vue2没有“app”的概念，我们定义的应用只是通过new Vue()创建的根Vue实例。从同一个Vue构造函数**创建的每个根实例共享相同的全局配置**因此：
- 在测试期间，全局配置很容易意外地污染其他测试用例，用户需要仔细存储原始全局配置，并在每次测试后恢复 (例如重置 Vue.config.errorHandler)。有些API像Vue.use以及Vue.mixin甚至连恢复效果的方法都没有，这使得涉及到插件的测试特别棘手，实际上，vue-test-utils 必须实现一个特殊的 API createLocalVue 来处理此问题：

- 全局配置使得在同一个页面上的多个“app”之间共享同一个Vue副本非常困难
 这会影响两个根实例
Vue.mixin({
  /* ... */
})

const app1 = new Vue({ el: '#app-1' })
const app2 = new Vue({ el: '#app-2' })

为了避免这些问题，vue3引入了createApp

# createApp
调用createApp返回一个应用实例
import { createApp } from 'vue'

const app = createApp({})

应用实例暴露了vue2当前全局API的子集，任何全局改变Vue行为的API都会移动到应用实例上 ***？？？为何vue2不把全局放在实例上？***
2.x 全局 API	            3.x 实例 API (app)
Vue.config	                app.config
Vue.config.productionTip	removed 
Vue.component               app.component
Vue.directive               app.directive
Vue.mixin                   app.mixin
Vue.use                     app.use
Vue.prototype               app.config.globalProperties

所有其他不全局改变行为的全局API现在被命名为exports
### config.productionTip 移除
在 Vue 3.x 中，“使用生产版本”提示仅在使用“dev + full build”(包含运行时编译器并有警告的构建) 时才会显示。
对于 ES 模块构建，由于它们是与 bundler 一起使用的，而且在大多数情况下，CLI 或样板已经正确地配置了生产环境，所以本技巧将不再出现

### onfig.ignoredElements 替换为 config.isCustomElement
引入此配置选项的目的是支持原生自定义元素，因此重命名可以更好地传达它的功能，新选项还需要一个比旧的 string/RegExp 方法提供更多灵活性的函数：
// 之前
Vue.config.ignoredElements = ['my-el', /^ion-/]

// 之后
const app = createApp({})
app.config.isCustomElement = tag => tag.startsWith('ion-')

### Vue.prototype替换为config.globalProperties
在vue2中，Vue.prototype通常用于添加所有组件都能访问的prototype
在vue3等同于config.globalProperties,这些property将被复制到应用中作为实例化组件的一部分
// 之前 - Vue 2
Vue.prototype.$http = () => {}
// 之后 - Vue 3
const app = createApp({})
app.config.globalProperties.$http = () => {}
### 插件使用者须知
插件开发者通常使用 Vue.use。例如，官方的 vue-router 插件是如何在浏览器环境中自行安装的：

var inBrowser = typeof window !== 'undefined'
/* … */
if (inBrowser && window.Vue) {
  window.Vue.use(VueRouter)
}
由于 use 全局 API 在 Vue 3 中不再使用，此方法将停止工作并停止调用 Vue.use() 现在将触发警告，于是，开发者必须在应用程序实例上显式指定使用此插件：

const app = createApp(MyApp)
app.use(VueRouter)

### 挂载App实例
使用 createApp(/* options */) 初始化后，应用实例 app 可用 app.mount(domTarget) 挂载根组件实例：
import { createApp } from 'vue'
import MyApp from './MyApp.vue'

const app = createApp(MyApp)
app.mount('#app')
经过所有这些更改，我们在指南开头的组件和指令将被改写为如下内容：
const app = createApp(MyApp)

app.component('button-counter', {
  data: () => ({
    count: 0
  }),
  template: '<button @click="count++">Clicked {{ count }} times.</button>'
})

app.directive('focus', {
  mounted: el => el.focus()
})

// 现在，所有通过 `app.mount()` 挂载的应用实例及其组件树，将具有相同的 “button-counter” 组件和 “focus” 指令，而不会污染全局环境
app.mount('#app')

# Provide/Inject
与在 2.x 根实例中使用 provide 选项类似，Vue 3 应用实例也提供了可被应用内任意组件注入的依赖项：
// 在入口
app.provide('guide', 'Vue 3 Guide')
// 在子组件
export default {
  inject: {
    book: {
      from: 'guide'
    }
  },
  template: `<div>{{ book }}</div>`
}

# 在应用之间共享配置
在应用之间共享配置(如组件或指令)的一种方法是创建工厂函数，如下所示
import { createApp } from 'vue'
import Foo from './Foo.vue'
import Bar from './Bar.vue'
const createMyApp = options => {
    const app = createApp(options)
    app.directive('focus', /* ... */)
    return app
}
createMyApp(Foo).mount('#foo')
createMyApp(Bar).mount('#bar')
现在，Foo 和 Bar 实例及其后代中都可以使用 focus 指令。

# v-model
### 2.x用法
在2.x中，在组件上使用v-model相当于绑定value prop和input事件
<ChildComponent v-model="pageTitle" />
<!-- 是以下的简写: -->
<ChildComponent :value="pageTitle" @input="pageTitle = $event" />

如果要将属性或事件名称改为其他名称，则需要在childComponent组件中**添加model选项**
<!-- ParentComponent.vue -->
<ChildComponent v-model="pageTitle" />
// ChildComponent.vue
export default {
  model: {
    prop: 'title',
    event: 'change'
  },
  props: {
    value: String, // 这将运行'value'属性用于其他用途
    title: {  // 使用 `title` 代替 `value` 作为 model 的 prop
      type: String,
      default: 'Default title'
    }
  }
}
所以，在这个例子中v-model是以下的缩写：
<ChildComponent :title="pageTitle" @change="pageTitle = $event" />

### 使用v-bind.sync
在某些情况下，我们可能需要对某一个prop进行"双向绑定"(除了前面用v-model绑定的prop的情况)，为此，我们建议使用update:mypropName抛出事件，例如，对于在上一个示例中带有title prop的childComponent，我们可以通过下面的方式将分配新value的意图传达给父级
this.$emit('update:title',newValue)
如果需要的话，父级可以监听该事件并更新本地data property。例如：
<ChildComponent :title="pageTitle" @update:title="pageTitle=$event">
为了方便起见，我们可以用.sync来缩写，如下所示：
<ChildComponent :title.sync="pageTitle">

### 3.x语法
在3.x中，自定义组件的v-model相当于传递了modelValue prop并接收抛出 的update:modelValue事件：
<ChildComponent v-model="pageTitle" />
是以下的简写:
<ChildComponent :modelValue="pageTitle" @update:modelValue="pageTitle = $event">

v-model参数：
若需要修改model的名称，而不是更改组件内的model选项，那么我们可以将一个argument传递给model
<ChildComponent v-model:title="pageTitle">
<!-- 是以下的简写 -->
<ChildComponent :title="pageTitle" @update.title="pageTitle = $event">

这也可以作为.sync修饰符的替代，而且允许我们在自定义组件上使用多个v-model
<ChildComponent v-model:title="pageTitle" v-model:content="pageContent">
<!-- 是以下的简写 -->
<ChildComponent
  :title="pageTitle"
  @update:title="pageTitle = $event"
  :content="pageContent"
  @update:content="pageContent = $event"
/>

# key attribute <template v-for> 和非 v-for 节点上 key 用法已更改
Vue 2.x 建议在 v-if/v-else/v-else-if 的分支中使用 key。
<!-- Vue 2.x -->
<div v-if="condition" key="yes">Yes</div>
<div v-else key="no">No</div>
这个示例在 Vue 3.x 中仍能正常工作。但是我们不再建议在 v-if/v-else/v-else-if 的分支中继续使用 key attribute，因为没有为条件分支提供 key 时，也会自动生成唯一的 key
<!-- Vue 3.x -->
<div v-if="condition">Yes</div>
<div v-else>No</div>
非兼容变更体现在如果你手动提供了 key，那么每个分支都必须使用一个唯一的 key。因此大多数情况下都不需要设置这些 key。
<!-- Vue 2.x -->
<div v-if="condition" key="a">Yes</div>
<div v-else key="a">No</div>

<!-- Vue 3.x (recommended solution: remove keys) -->
<div v-if="condition">Yes</div>
<div v-else>No</div>

<!-- Vue 3.x (alternate solution: make sure the keys are always unique) -->
<div v-if="condition" key="a">Yes</div>
<div v-else key="b">No</div>


在 Vue 2.x 中 <template> 标签不能拥有 key。不过你可以为其每个子节点分别设置 key。
<!-- Vue 2.x -->
<template v-for="item in list">
  <div :key="'heading-' + item.id">...</div>
  <span :key="'content-' + item.id">...</span>
</template>

在 Vue 3.x 中 key 则应该被设置在 <template> 标签上。

<!-- Vue 3.x -->
<template v-for="item in list" :key="item.id">
  <div>...</div>
  <span>...</span>
</template>

# 在同一元素上使用的 v-if 和 v-for 优先级已更改  两者作用于同一个元素上时，v-if 会拥有比 v-for 更高的优先级。

2.x版本中在一个元素上同时使用v-if和v-for时，v-for会优先作用

3.x版本中v-if总是由于v-for生效
<!-- This will throw an error because property "todo" is not defined on instance. -->

<li v-for="todo in todos" v-if="!todo.isComplete">
  {{ todo.name }}
</li>

由于语法上存在歧义，建议避免在同一元素上同时使用两者。
起在模板层面管理相关逻辑，更好的办法是通过创建计算属性筛选出列表，并以此创建可见元素。

# v-bind="object" 现在排序敏感 v-bind 的绑定顺序会影响渲染结果。
在 2.x，如果一个元素同时定义了 v-bind="object" 和一个相同的单独的 property，那么这个单独的 property 总是会覆盖 object 中的绑定。
<!-- template -->
<div id="red" v-bind="{ id: 'blue' }"></div>
<!-- result -->
<div id="red"></div>
在 3.x，如果一个元素同时定义了 v-bind="object" 和一个相同的单独的 property，那么声明绑定的顺序决定了它们如何合并。换句话说，相对于假设开发者总是希望单独的 property 覆盖 object 中定义的内容，现在开发者对自己所希望的合并行为有了更好的控制
<!-- template -->
<div id="red" v-bind="{ id: 'blue' }"></div>
<!-- result -->
<div id="blue"></div>


<!-- template -->
<div v-bind="{ id: 'blue' }" id="red"></div>
<!-- result -->
<div id="red"></div>

# v-on 的 .native 修饰符已被移除。

2.x版本中，默认情况下，传递给带有v-on的组件的事件监听器只有通过this.emit才能触发，要将原生DOM监听器添加到子组件的根元素中，可以使用 .native修饰符
<my-component v-on:close="handleComponentEvent"  v-on:click.native="handleNativeClickEvent">

3.x移除了.native修饰符，同时，新增的emits选项允许子组件定义真正会被触发的事件
因此，对于子组件中未被定义为组件触发的所有事件监听器，Vue现在将把它们作为原生事件监听器添加到子组件的根元素中(除非在子组件的选项中设置了inheritAttrs: false)
<my-component
  v-on:close="handleComponentEvent"
  v-on:click="handleNativeClickEvent"
/>


<!-- MyComponent.vue -->

<script>
  export default {
    emits: ['close']
  }
</script>


# v-for 中的 ref 不再注册 ref 数组
在 Vue 2 中，在 v-for 里使用的 ref attribute 会用 ref 数组填充相应的 $refs property。当存在嵌套的 v-for 时，这种行为会变得不明确且效率低下。

在 Vue 3 中，这样的用法将不再在 $ref 中自动创建数组。要从单个绑定获取多个 ref，请将 ref 绑定到一个更灵活的函数上 (这是一个新特性)：
<div v-for="item in list" :ref="setItemRef"></div>
结合选项式 API:

export default {
  data() {
    return {
      itemRefs: []
    }
  },
  methods: {
    setItemRef(el) {
      if (el) {
        this.itemRefs.push(el)
      }
    }
  },
  beforeUpdate() {
    this.itemRefs = []
  },
  updated() {
    console.log(this.itemRefs)
  }
}
结合组合式 API:

import { onBeforeUpdate, onUpdated } from 'vue'

export default {
  setup() {
    let itemRefs = []
    const setItemRef = el => {
      if (el) {
        itemRefs.push(el)
      }
    }
    onBeforeUpdate(() => {
      itemRefs = []
    })
    onUpdated(() => {
      console.log(itemRefs)
    })
    return {
      setItemRef
    }
  }
}

itemRefs 不必是数组：它也可以是一个对象，其 ref 会通过迭代的 key 被设置。

如果需要，itemRef 也可以是响应式的且可以被监听。


# 只能使用普通函数创建功能组件 函数式组件

在vue2中，函数式组件有两个主要应用场景：
- 作为性能优化，因为它们的初始化速度比有状态组件快得多
- 返回多个根节点
然而在vue3中，有状态组件的性能已经提高到可以忽略不计的程度，此外，有状态组件现在还包括返回多个根节点的功能
因此，函数式组件剩下的唯一应用场景就是简单组件，比如创建动态标题的组件。否则，建议你像平时一样使用有状态组件

2.x语法：
使用<dynamic-heading>组件，负责提供适当的标题 (即：h1，h2，h3，等等)，在 2.x 中，这可能是作为单个文件组件编写的：
// vue2函数式组件示例
export default {
  functional: true,
  props: ['level'],
  render h(`h${props.level}`,data,children)
}
或者，对于喜欢在单个文件组件中使用 <template> 的用户：
<!-- Vue 2 函数式组件示例使用 <template> -->
<template functional>
  <component
    :is="`h${props.level}`"
    v-bind="attrs"
    v-on="listeners"
  />
</template>

<script>
export default {
  props: ['level']
}
</script>

3.x语法
通过函数创建组件
在vue3中，所有的函数式组件都是普通函数创建的，换句话说，不需要定义{ functional: true } 组件选项。
它们将接收两个参数：props和context，context参数是一个对象，包含组件的attrs，slots，和emit property
此外，现在不是在render函数中隐式提供h，而是全局引入h
使用前面提到的 <dynamic-heading> 组件的示例，下面是它现在的样子。

import { h } from 'vue'
const DynamicHeading = (props, context) => {
  return h(`h${props.level}`, context.attrs, context.slots)
}
DynamicHeading.props = ['level']
export default DynamicHeading

在 3.x 中，有状态组件和函数式组件之间的性能差异已经大大减少，并且在大多数用例中是微不足道的。因此，在 单文件组件 (SFC) 上使用 functional 的开发人员的迁移路径是删除该 attribute，并将 props 的所有引用重命名为 $props，将 attrs 重命名为 $attrs。
使用之前的 <dynamic-heading> 示例，下面是它现在的样子。
<template>
  <component
    v-bind:is="`h${$props.level}`"
    v-bind="$attrs"
  />
</template>

<script>
export default {
  props: ['level']
}
</script>


# 异步组件现在需要 defineAsyncComponent 方法来创建

### vue2异步组件
在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块，为了简化，vue允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义，vue只有在这个组件需要被渲染的时候才会触发该工厂函数，并把结果缓存起来供未来重渲染
Vue.component('async-example', function (resolve, reject) {
  setTimeout(function () {
    // 向 `resolve` 回调传递组件定义
    resolve({
      template: '<div>I am async!</div>'
    })
  }, 1000)
})
如你所见，这个工厂函数会收到一个resolve的回调，这个回调函数会在你从服务器得到组件定义的时候被调用，你也可以调用reject(reason)来表示加载失败，这里的 setTimeout 是为了演示用的，如何获取组件取决于你自己。一个推荐的做法是将异步组件和 webpack 的 code-splitting 功能一起配合使用：
Vue.component('async-webpack-example', function (resolve) {
  // 这个特殊的 `require` 语法将会告诉 webpack
  // 自动将你的构建代码切割成多个包，这些包
  // 会通过 Ajax 请求加载
  require(['./my-async-component'], resolve)
})

你也可以在工厂函数中返回一个Promise，所以把 webpack 2 和 ES2015 语法加在一起，我们可以这样使用动态导入：
Vue.component(
  'async-webpack-example',
  // 这个动态导入会返回一个 `Promise` 对象。
  () => import('./my-async-component')
)
当使用局部注册的时候，你也可以直接提供一个返回 Promise 的函数：

new Vue({
  // ...
  components: {
    'my-component': () => import('./my-async-component')
  }
})

处理加载状态：
这里的异步组件工厂函数也可以返回一个如下格式的对象：
const AsyncComponent = () => ({
  // 需要加载的组件 (应该是一个 `Promise` 对象)
  component: import('./MyComponent.vue'),
  // 异步组件加载时使用的组件
  loading: LoadingComponent,
  // 加载失败时使用的组件
  error: ErrorComponent,
  // 展示加载时组件的延时时间。默认值是 200 (毫秒)
  delay: 200,
  // 如果提供了超时时间且组件加载也超时了，
  // 则使用加载失败时使用的组件。默认值是：`Infinity`
  timeout: 3000
})

**vue2 异步组件是通过将组件定义为返回Promise的函数来创建的**
const asyncModal = () => import('./Modal.vue')
或者，对于带有选项的更高阶的组件语法：
const asyncModal = {
  component: () => import('./Modal.vue'),
  delay: 200,
  timeout: 3000,
  error: ErrorComponent,
  loading: LoadingComponent
}


vue3
在vue3中，由于函数式组件被定义为纯函数，因此异步组件的定义需要通过将其包裹在新的defineAsyncComponent助手方法来显示地定义
import { defineAsyncComponent } from 'vue'
import ErrorComponent from './components/ErrorComponent.vue'
import LoadingComponent from './components/LoadingComponent.vue'

// 不带选项的异步组件
const asyncModal = defineAsyncComponent(() => import('./Modal.vue'))


// 带选项的异步组件
const asyncModalWithOptions = defineAsyncComponent({
  loader: () => import('./Modal.vue'),
  delay: 200,
  timeout: 3000,
  errorComponent: ErrorComponent,
  loadingComponent: LoadingComponent
})

**vue Router 支持一个类似的机制来异步加载路由组件，也就是俗称的懒加载。尽管类似，这个功能和 Vue 支持的异步组件是不同的。当用 Vue Router 配置路由组件时，你不应该使用 defineAsyncComponent。**

# 组件事件现在需要在 emits 选项中声明

# 渲染函数API改变
在 2.x 中，render 函数会自动接收 h 函数 (它是 createElement 的传统别名) 作为参数：

// Vue 2 渲染函数示例
export default {
  render(h) {
    return h('div')
  }
在 3.x 中，h 现在是全局导入的，而不是作为参数自动传递。

// Vue 3 渲染函数示例
import { h } from 'vue'

export default {
  render() {
    return h('div')
  }
}

# 插槽统一
2.x 语法
当使用渲染函数时，即 h，2.x 用于在内容节点上定义 slot 数据 property。

// 2.x 语法
h(LayoutComponent, [
  h('div', { slot: 'header' }, this.header),
  h('div', { slot: 'content' }, this.content)
])

此外，在引用作用域插槽时，可以使用以下方法引用它们：

// 2.x 语法
this.$scopedSlots.header


在 3.x 中，将插槽定义为当前节点的子对象：

// 3.x Syntax
h(LayoutComponent, {}, {
  header: () => h('div', this.header),
  content: () => h('div', this.content)
})

当你需要以编程方式引用作用域插槽时，它们现在被统一到 $slots 选项中。

// 2.x 语法
this.$scopedSlots.header

// 3.x 语法
this.$slots.header()


# $listeners 对象在 Vue 3 中已被移除。现在事件监听器是 $attrs 的一部分：
# 现在 $attrs 包含传递给组件的所有 attribute，包括 class 和 style
# 自定义指令 API 已更改为与组件生命周期一致
# 在 3.x，data 选项已标准化为只接受返回 object 的 function。


# Mixin 合并行为变更
此外，当来自组件的 data() 及其 mixin 或 extends 基类被合并时，现在将浅层次执行合并：
const Mixin = {
  data() {
    return {
      user: {
        name: 'Jack',
        id: 1
      }
    }
  }
}
const CompA = {
  mixins: [Mixin],
  data() {
    return {
      user: {
        id: 2
      }
    }
  }
}
在 Vue 2.x 中，生成的 $data 是：

{
  "user": {
    "id": 2,
    "name": "Jack"
  }
}

在 3.0 中，其结果将会是：

{
  "user": {
    "id": 2
  }
}

# 当侦听一个数组时，只有当数组被替换时才会触发回调。如果你需要在数组改变时触发回调，必须指定 deep 选项。
3.x 语法
当使用 watch 选项侦听数组时，只有在数组被替换时才会触发回调。换句话说，在数组改变时 watch 回调将不再被触发。要想在数组改变时触发 watch 回调，必须指定 deep 选项。

watch: {
  bookList: {
    handler(val, oldVal) {
      console.log('book list changed')
    },
    deep: true
  },
}
# 从 Vue 3.0 开始，过滤器已删除，不再支持。