# Vue的生命周期

生命周期4个阶段： 初始化阶段，模板编译阶段，挂载阶段，卸载阶段
初始化阶段：new Vue() 到created之间
            目的： 在Vue实例上初始化一些属性、事件以及响应式数据 如props，methods，data，computed，watch，provide和inject等

模板编译阶段： created钩子函数与beforeMounted钩子函数之间的阶段
                目的：将模板编译成渲染函数，只存在于完整版本中，如果在只包含运行时的版本中不存在这个阶段
                当使用vue-loader或vueify时，*.vue文件内部的模板会在构建时预编译成JavaScript，所以最终打包好的包里是不需要编译器的，用运行时版本即可。由于模板此时已经预编译成了渲染函数，所以在生命周期中并不存在模板编译阶段，初始化阶段的下一个生命周期直接是挂载阶段。


挂载阶段：beforeMount钩子函数到mounted钩子函数之间是挂载阶段
          这个阶段，vue会将其实例挂载到DOM元素上，就是将模板渲染到指定的DOM元素上，在挂载的过程中，vue会开启watcher来追踪依赖的变化

卸载阶段： 应用调用vm.$destroy方法，vue的生命周期进入卸载阶段，vue会将自身从父组件中删除，取消实例上所有的追踪，并且移除所有的事件监听器

## new Vue() 被调用时发生了什么
首先安全检查，是否用new来调用Vue
然后调用this._init来执行生命周期初始化流程

## callHook原理
作用：触发用户设置的生命周期钩子
用户设置的生命周期钩子会在执行new Vue() 时通过参数传递给vue，也就是说，也就是说可以在vue的构造函数中通过options参数得到用户设置的生命周期钩子。
用户传入的options参数最终会与构造函数的options属性合并生成新的options并赋值到vm.$options属性中

callHook的实现只需要从vm.$options中获取生命周期钩子列表，遍历列表，执行每一个生命周期钩子


## 初始化顺序
props methods data computed watch

### props原理
vue中的所有组件都是vue实例，组件在进行模板解析时，会把标签上的属性解析成数据，最终生成渲染函数。
而渲染函数被执行时，会生成真实的DOM节点并渲染到视图上。但是这里面有一个细节，如果某个节点是组件节点，也就是说在模板中的某个标签的名字是组件名，那么在虚拟DOM渲染的过程中会将子组件实例化，这会将模板解析时从标签属性上解析出的数据当作参数传递给子组件，其中就包含props数据。
模板解析时从组件标签上解析出来的数据传给子组件，首先将解析出来的数据规格化成对象格式，将这些数据保存至vm._props上，然后在vm上设置一个代理，实现通过vm.x访问vm._props.x的目的
子组件将props保存在自身实例的_props上，并且逐一复制到实例上，并且每个属性都会被设置为响应式的

设置get：读取的时候 this.prop 实际上访问this._props.prop

父组件数据变化，视图更新，模板解析。开启新一轮props赋值，然后更新子组件视图

### methods原理
初始化methods时，循环options.methods对象，将每个属性依次挂载到vm上

### data初始化
data中的数据最终会保存在vm._data中，同样设置代理，vm.x可以访问vm._data.x。并且需要对这些数据进行响应式处理


### 生命周期
#### 每个生命周期什么时候被调用

- beforeCreate  在实例初始化之后，数据观测之前被调用 初始化_update 初始化事件 初始化render函数
- created 实例已经创建完成之后调用，在这一步实例已经完成数据观测，初始化状态，顺序：props，methods，data，computed，watch，但是没有挂载获取不到DOM
-（服务端渲染不可用） beforeMount 在挂载开始之前调用:相关的render函数首次被调用
-（服务端渲染不可用） mounted el被创建的vm.$el替换，并挂载到实例上之后调用该钩子
- （服务端渲染不可用）beforeUpdate 数据更新时调用，发生在虚拟DOM重新渲染和patch之前
- （服务端渲染不可用）updated 由于数据更改导致的虚拟DOM重新渲染和patch之后调用
- （在服务端渲染期间不被调用）beforeDestory 实例销毁之前调用，在这一步实例依然完全可用
-（在服务端渲染期间不被调用） destroy vue实例被销毁，调用后vue实例的所有东西都解绑，所有的子实例都会被销毁，监听器也会被移除
  - activated 被keep-alive缓存的组件被激活时调用 **在服务端渲染期间不被调用**
  - deactivated 被keep-alive缓存的组件被销毁时调用 **在服务端渲染期间不被调用**
  - errorCaptured 
  当捕获一个来自子孙组件的错误时被调用，此钩子会接收三个参数：错误对象、发生错误的组件实例，以及一个包含错误来源信息的字符串，此钩子可以返回false以阻止该错误继续向上传播
  你可以在此钩子中修改组件的状态，因此在捕获错误时，在模板或渲染函数中有一个条件判断绕过其它内容就很重要，不然该组件可能会进入一个无限的渲染循环

  #### 每个生命周期内部可以做什么
  - created 资源请求 能够获取数据
  - mounted 挂载完成 可以DOM操作，请求资源
  - beforeUpdate 进一步更改状态，不会触发附加的重渲染
  - updated 可以执行依赖于DOM的操作，然而大多数情况下应该避免在此更改状态，可能会导致更新无限循环
  - beforeDestroy 清空定时器 解绑事件等