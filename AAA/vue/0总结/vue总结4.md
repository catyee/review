# 用虚拟node描述一个DOM结构
虚拟节点是用一个对象来描述真实的dom元素
标签名，属性，子元素对象
先将dom转换成ast语法树，再生成vnode



# ast语法树和虚拟DOM区别
编译器将template 编译成ast语法树，然后生成render函数，然后执行render函数生成vnode
# DOM diff原理实现 js计算成本换取dom操作成本
diff算法就是进行虚拟节点比对，对现有dom进行修改
修改包括： 创建新增节点，删除废弃节点，修改更新节点

diff做法：
对新旧节点中父节点是相同节点的那一层进行比较，也就是说只有两个新旧节点是相同节点的时候才会比较他们各自的子节点

patch 判断oldVnode是否存在，不存在的话使用vnode创建节点并插入视图，如果存在，判断oldVnodee和vnode是否是同一个节点，如果不是使用vnode创建真实节点并插入到视图中旧节点的旁边，然后删除旧节点。如果oldVnode和vnode是同一个节点，使用patchNode进行更详细的对比及更新操作。

更新子节点，循环newChildren，每循环到一个子节点，就去oldChildren中找和当前节点相同的旧子节点，如果找不到，则是新增，如果找到了就更新，如果找到了但是位置不同需要移动

diff特点：
比较只会在同级比较，不会跨层级比较
在diff比较的过程中，循环从两边向中间比较

比较方式：
1. 同级，不跨层级
2. 比较的过程中，循环从两边向中间收拢

● oldStartVnode：oldChildren中所有未处理的第一个节点，与前文中提到的“旧前”是同一个节点。

● oldEndVnode：oldChildren中所有未处理的最后一个节点，与前文中提到的“旧后”是同一个节点。

● newStartVnode：newChildren中所有未处理的第一个节点，与前文中提到的“新前”是同一个节点。

● newEndVnode：newChildren中所有未处理的最后一个节点，与前文中提到的“新后”是同一个节点。

old：A B C D
new: D C E A B F

D A B C 第一次循环找到D，直接复用D节点作为diff后创建的第一个真实节点
D C A B 复用C
第三次：找不到E 创建E

优化策略：
通常情况下，并不是所有的子节点的位置都会发生移动，一个列表中总有几个节点的位置是不变的，针对这些位置不变的或者说位置可以预测的节点，我们不需要循环来查找，因为我们有一个更快捷的查找方式。
假设一个场景，我们只是修改了列表中的某个数据的内容，而没有新增数据或删除数据，这种情况下新旧children中所有节点的位置都是相同的，这时节点的位置是可以预测的，不需要循环也可以知道oldChildren中哪个节点和被寻找的子节点是同一个节点。
只需要尝试使用相同位置的两个节点来比对是否是同一个节点：如果恰巧是同一个节点，直接进入更新节点的操作，如果尝试失败了，再用循环的方式来查找节点。
这样做可以很大程度避免循环oldChildren来查找节点，从而提升速度

这种快捷查找有四种方式：
新前与旧前
新后与旧后
新后与旧前
新前与旧后

挨个尝试这四种方式，如果都不行，再使用索引比较。





# DOM diff时间复杂度
两个树的完全的diff算法是一个时间复杂度为O(n3),vue进行了优化转换为O(n),只比较同级不考虑跨级
o(n)


# key的作用
key可以标示一个节点的唯一id。在更新子节点时，需要在oldChildren中循环去找一个节点，如果设置了key，那么在oldChildren中找相同节点时，可以根据key直接拿到，这样根本不需要通过循环来查找了。

vue使用v-for更新已渲染的元素列表时，默认采用就地复用策略，如果数据项顺序被改变，vue将不会移动DOM元素来匹配数据项顺序，而是简单复用此处每个元素
高效的更新虚拟DOM

删除的时候不加key会复用元素，导致真正删除的是最后一个元素
不要用索引作为key



# 为什么只能有一个根元素 vue3为什么又可以了
diff算法要求，实例化Vue需要一个el选项



# slot原理
# keep-alive理解
可以实现组件的缓存，四个属性，两个生命周期
LRU算法
# 设计模式
# 哪些watcher 
# vue组件渲染和更新过程

# 异步组件
是一个函数，新版本提供了返回对象的写法，更新完之后强制刷新

# 组件中data为什么是函数，new Vue为什么可以是对象（不复用）

# 事件绑定原理
普通标签：addEventListener
组件标签：组件中native等价于普通标签：addEventListener 
@click = $on

# v-model 组件和元素
# v-html 
# 父子组件生命周期调用顺序
# 作用域插槽
插槽在外层组件渲染
普通插槽渲染位置在父组件里，父组件渲染好的结果替换在子组件里


作用域插槽在组件里面


