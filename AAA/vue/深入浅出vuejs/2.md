### 虚拟DOM
虚拟DOM的解决方式是通过状态生成一个虚拟节点树，然后使用虚拟节点树进行渲染。在渲染之前，会使用新生成的虚拟节点树和上一次生成的虚拟节点树进行对比，只渲染不同的部分
虚拟节点树其实是由组件树建立起来的整个虚拟节点，经常简写为vnode树
vnode描述应该怎样去创建真实的DOM节点
vnode和DOM视图是一一对应的，我们可以把vnode理解成js对象版本的DOM元素
渲染视图的过程是先创建vnode，然后再使用vnode去生成真实的DOM元素，最后插入到页面渲染视图

只要组件使用的众多状态中有一个发生了变化，那么整个组件就要重新渲染
如果组件只有一个节点发生了变化，那么重新渲染整个组件的所有节点，很明显会造成很大的性能浪费，因此，对vnode进行缓存，并将上一次缓存的vnode和当前新创建的vnode进行对比，只更新发生变化的节点就变得尤为重要。



### 模板编译

#### 模板——》模板编译——》渲染函数——》vnode——》用户界面

将模板编译成渲染函数可以分为两个步骤，先将模板解析成AST语法树(抽象语法树)，然后再使用AST生成渲染函数
但是由于静态节点不需要总是重新渲染，所以在生成AST之后，生成渲染函数之前这个阶段，需要做一个操作，那就是遍历一遍AST，给所有的静态节点做一个标记，这样在虚拟DOM中更新节点时，如果发现节点有这个标记，就不会重新渲染它








vue完整版本和运行时版本：
运行时版本不包含编译器，一般在生产环境使用，因为.vue文件内部的模板会在构建时预编译成js，所以最终打包完成的文件实际上不需要编译器的，所以只需要引入运行时版本即可，运行时版本比完整版小30%左右，所以应该尽可能使用运行时版本

vue事件：$on,$emit
在注册事件的时候把回调函数收集起来，在触发事件的时候把收集起来的回调函数依次调用


每一个组件都是vuejs实例，在vue实例上有一个watcher，也就是vm._watcher,它会监听这个组件中用到的所有状态，即这个组件内用到的所有状态的依赖都会收集到vm._watcher中，当这些状态发生变化时，也会通知vm._watcher,然后这个watcher再调用虚拟DOM进行重新渲染


nextTick接收一个回调函数作为参数，它的作用是将回调延迟到下次DOM更新周期之后执行。它与全局方法Vue.nexTick一样，不同的是回调的this自动绑定到调用它的实例上。如果没有提供回调且在支持Promise的环境中，则返回一个Promise。
我们在开发项目时遇到一种场景：当更新了状态(数据)后，需要对新DOM做一些操作，但是这时我们其实获取不到更新后的DOM，因为还没有重新渲染，这个时候我们需要使用nextTick方法
## 什么是下次DOM更新周期？ 下次微任务执行时更新DOM，只有特殊情况下才会降级成宏任务
更新DOM的回调也是使用vm.$nextTick来注册到微任务中的，如果想在vm.$nextTick中获取更新后的DOM，则一定要在更改数据的后面使用vm.$nextTick注册回调，

在vue中，当状态发生变化时，watcher会得到通知，然后触发虚拟DOM的渲染流程，而watcher触发渲染这个操作并不是同步的，而是异步的，vue中有一个队列，每当需要渲染时，会将wacher推送到这个队列中，在下一次事件循环中再让wacher触发渲染的流程

为什么vue使用异步更新队列
vue使用虚拟DOM进行渲染，变化侦测的通知只发送到组件，组件内用到的所有状态的变化都会通知到同一个wacher，然后虚拟DOM会对整个组件进行比对，并修改DOM，也就是说，如果在同一轮事件循环中有两个数据发生了变化，那么组件的wacher会收到两份通知，从而进行两次渲染，事实上，并不需要渲染两次，虚拟DOM会对整个组件进行渲染，所以只需要等所有状态都修改完毕，一次性将整个组件的DOM渲染到最新即可
要解决这个问题，vue的实现方式是将收到通知的wacher实例添加到队列中缓存起来，并且在添加到队列之前检查其中是否已经存在相同的wacher，只有不存在时，才将wacher实例添加到队列中。然后在下一次事件循环中，vue会让队列中的wacher触发渲染流程并清空队列，这样就可以保证即便在同一事件循环中有两个状态发生改变，wacher最后也只执行一次渲染流程

事件循环：
js是非阻塞单线程的脚本语言，这意味着js代码在执行的任何时候都只有一个主线程来处理所有任务，而非阻塞是指当代码需要处理异步任务时，主线程会挂起这个异步任务，当异步任务处理完毕后，主线程再根据一定的规则去执行相应异步任务对应的回调

事实上，当任务处理完毕后，js会将这个事件加入一个队列中，我们称这个队列为事件队列。被放入事件队列的事件不会立即执行其回调，而是等待当前执行栈中的所有任务执行完毕后，主线程会去查找事件队列中是否有任务。
异步任务有两种：微任务，宏任务，不同类型任务分配到不同的任务队列

当执行栈中的所有任务都执行完毕后，会去检查微任务队列中是否有事件存在，如果存在，则会依次执行微任务队列中事件对应的回调，直到为空。然后去宏任务队列中取出一个事件，把对应的回调加入到当前执行栈，当执行栈中的所有任务都执行完毕后，检查微任务队列中是否有事件存在。无限重复此过程，就形成了一个无限循环，这个循环就叫作事件循环


# Vue.use 
安装vue插件，如果插件是一个对象，必须提供install方法，如果插件是一个函数，它会被作为install方法。调用install方法时，会将vue作为参数传入，install方法被同一个插件多次调用时，插件也只会被安装一次

vue初始化状态顺序：props methods data computed watch



