### 1. 对象的变化侦测
利用Object.defineProperty 在getter中收集依赖 在setter中触发依赖
依赖收集到Dep实例上
对于对象：不能检测数据的新增属性和删除属性，只能追踪对象的属性是否被修改 

data通过Observer转换成了getter/setter的形式来追踪变化
当外界通过Watcher读取数据时，会触发getter从而将Watcher添加到依赖中
当数据发生了变化时，会触发setter，从而向Dep中的依赖(Watcher)发送通知
Watcher接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数

### 2. 数组的变化侦测
数组方法比如push并不会触发getter，setter，所以需要单独处理
用一个拦截器覆盖Array.property，之后每当使用Array原型上的方法操作数组时，实际上执行的都是拦截器中提供的方法，然后在拦截器中使用原生Array的原型方法去操作数组

Array中可以改变数组自身内容的方法有7个：push pop splice shift unshift reverse sort

Observer中使用拦截器覆盖那些即将被转换成响应式Array类型数据的原型

export class Observer {
    constructor(value) {
        this.value = value
        if(Array.isArray(value)){
            // **数组 拦截器覆盖原型**
            value.__proto__ = arrayMethods
        }else {
            this.walk(value)
        }
    }
   
}

使用hasProto判断浏览器是否支持 __proto__：如果支持，则使用protoAugment函数来覆盖原型；如果不支持，则调用copyAugment函数将拦截器中的方法挂载到value上。

**Array在getter中收集依赖，在拦截器中触发依赖**
数组中的每一项循环递归，将数组子数据转换成响应式的

- 数组中新增元素的变化 比如push 获取新增的元素并使用Observer来侦测
Observer会将自身的实例附加到value的__ob__属性上，所有被侦测了变化的数据都有一个__ob__属性，在拦截器中可以通过this访问到__ob__

- 数组侦测的缺陷
    1. 修改数组中某一项的值时，无法侦测数组的变化，数组元素如果是对象可以侦测其变化
    2. 修改数组的长度也无法侦测数组的变化

### vm.$watch

- vue vm.$watch 用于观察一个表达式或computed函数在Vue.js实例上的变化，表达式只接受以点分隔的路径，例如a.b.c。如果是一个比较复杂的表达式，可以采用函数代替
vm.$watch返回一个取消观察的函数，用来停止触发回调

有两个选项
vm.$watch('someObject',callback, {
    deep: true,
    immediate: true
})

deep: true监听对象内部值的变化，监听数组的变动不需要这么做
immediate: true 将立即以表达式的当前值触发回调


- vm.$watch的内部原理 其实是对Watcher的一种封装
