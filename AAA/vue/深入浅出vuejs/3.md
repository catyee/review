1. 为列表渲染设置属性key
key这个特殊属性主要用在vue的虚拟DOM算法中，在对比新旧虚拟节点时辨识虚拟节点。
虚拟DOM在更新子节点时，需要从旧虚拟节点列表中查找与新虚拟节点相同的节点进行更新。如果这个查找过程设置了属性key，那么查找速度会快很多。

2. 在v-if/v-if-else/v-else中使用key
如果一组v-if+v-else的元素类型相同，最好使用属性key(比如两个div元素)
v-if指令在编译后是下面这样：
(has)?_c('li',[_v('if')]):_c('li',[_v("else")])
所以当状态发生变化时，生成的虚拟节点既有可能是v-if上的虚拟节点，也有可能是v-else上的虚拟节点

默认情况下，vue会尽可能高效地更新DOM。这意味着，当它在相同类型的元素之间切换时，会修补已经存在的元素，而不是将旧的元素移除，然后在同一位置添加一个新元素。如果本不相同的元素被识别为相同，则会出现意料之外的副作用。

如果添加了属性key，那么在比对虚拟DOM时，则会认为它们是两个不同的节点，于是会将旧元素移除并在相同的位置添加一个新元素，从而避免意料之外的副作用。

3. 路由切换组件不变

在使用vue开发项目时，会遇到一个典型问题就是，当页面切换到同一个路由但不同参数的地址时，组件的生命周期钩子并不会重新触发
当我们从路由/detail/1切换到/detail/2时，组件是不会发生任何变化的。

这是因为vue-router会识别出两个路由使用的是同一个组件从而进行复用，并不会重新创建组件，因此组件的生命周期钩子自然也不会被触发

组件本质上是一个映射关系，所以先销毁再创建一个相同的组件会造成很大程度上的性能浪费，复用组件才是正确的选择。但是这也意味着组件的生命周期钩子不会再被调用。

3个方法解决这个问题：
(1) 使用导航守卫beforeRouteUpdate，该守卫在当前路由改变且组件被复用时调用
 因此只需要把每次切换路由时需要执行的逻辑方法beforeRouteUpdate守卫即可

(2) 观察$route对象的变化
通过watch可以监听到路由对象发生的变化，从而对路由变化作出响应
watch: {
    '$route'(to,from) {
        // 对路由变化作出响应
    }
}
这种方式可以解决上述问题，但是代价是组件内多了一个watch，这会带来依赖追踪的内存开销

(3) 为router-view组件添加属性key
这种做法非常取巧，非常“暴力”，但非常有效。它本质上是利用虚拟DOM在渲染时通过key来对比两个节点是否相同的原理。通过给router-view组件设置key，可以使每次切换路由时的key都不一样，让虚拟DOM认为router-view是一个新节点，从而先销毁组件，然后重新创建新组件，即使是相同的组件，但是如果url变了，key就变了，vue就会重新创建这个组件。
这种方式的坏处很明显，每次切换录音组件时都会被销毁并且重新创建，非常浪费性能。


4. 为所有的路由统一添加query
如果路由上的query中有一些是从上游链路上传下来的，那么需要的应用的任何路由中携带，但是在所有跳转路由的地方都设置一遍会非常麻烦，例如，在应用中的所有路由上都加上参数：https://berwin.me/a?referer=hao360cn 和 https://berwin.me/b?referer=hao360cn

理想状态是，在全局统一配置一个基础的query，它会在应用的所有路由中携带，并且不影响应用中各个路由的切换，也无需在切换路由时进行任何特殊处理
遗憾的是vue-router并没有提供任何相应的API来处理这种情况。
下面提供了两种方式来解决这个问题：

(1) 使用全局守卫beforeEach
事实上，全局守卫beforeEach并不具备修改query的能力，但可以在其中使用next方法来中断当前导航，并切换到新导航，添加一些新query进去。
当然，单单这样做会出问题，因为在进入新导航后，依然会被全局守卫beforeEach拦截，然后再次开启新导航，从而导致无限循环。
解决方法是在beforeEach中判断这个全局添加的参数在路由对象中是否存在，如果存在，则不开启新导航
const query = {referer: 'hao360cn'}
router.beforeEach((to,from,next) => {
    to.query.referer? next() : next({...to,query:{...to.query,...query}})
})
这种方式的优点是：可以全局统一配置公共的query参数，并且在组件内切换路由时进行特殊处理。缺点是每次切换路由时，全局守卫beforeEach会执行两次，即每次切换路由其实是切换两次

下面这种方法完美解决了这个问题

(2)使用函数劫持
这种方法的原理是：通过拦截router.history.transitionTo方法，在vue-router内部在切换路由之前将参数添加到query中


5. 区分VueX与props的使用边界
对于通用组件使用props以及事件进行父子组件间的通信（通用组件不需要兄弟组件间的通信）。这样做是因为通用组件会拿到各个业务组件中使用，它需要与业务解耦，所以需要使用props获取状态

6. 避免v-if和v-for一起使用
Vue.js官方强烈建议不要把v-if和v-for同时用在同一个元素上。

7. 为组件样式设置作用域
css的规则都是全局的，任何一个组件的样式规则都对整个页面有效。因此，我们很容易在一个组件中写了某个样式，而不小心影响了另一个组件的样式，或者自己的组件被第三方库的CSS影响了。
对于应用来说，最佳实践是只有顶级App组件和布局组件中的样式可以是全局的，其他所有组件都应该是有作用域的。
注意　这条规则只在单文件组件下生效。
在Vue.js中，可以通过scoped特性或CSS Modules（一个基于class的类似BEM的策略）来设置组件样式作用域。

8. 避免在scoped中使用元素选择器
9. 避免隐性的父子组件通信
我们应该优先通过prop和事件进行父子组件之间的通信，而不是使用this.$parent或改变prop。

10. 单文件组件如何命名
 (1) 单文件组件的文件名应该始终是单词首字母大写（PascalCase），或者始终是横线连接的（kebab-case）。
 (2) 应用特定样式和约定的基础组件（也就是展示类的、无逻辑的或无状态的组件）应该全部以一个特定的前缀开头，比如Base、App或V。这些组件可以为你的应用奠定一致的基础样式和行为。它们可能只包括：
 (3) 只拥有单个活跃实例的组件以The前缀命名，以示其唯一性。但这并不意味着组件只可用于一个单页面，而是每个页面只使用一次。这些组件永远不接受任何prop，因为它们是为你的应用定制的，而不是应用中的上下文。如果你发现有必要添加prop，就表明这实际上是一个可复用的组件，只是目前在每个页面里只使用了一次。
 TheHeading.vue
 (4) 和父组件紧密耦合的子组件应该以父组件名作为前缀命名。
 (5) 组件名应该以高级别的（通常是一般化描述的）单词开头，以描述性的修饰词结尾。
 SearchButtonClear.vue
 SearchButtonRun.vue
 (6) 组件名应该倾向于完整单词而不是缩写
 (7) 组件名应该始终由多个单词组成，但是根组件App除外。这样做可以避免与现有的以及未来的HTML元素相冲突，因为所有的HTML元素名称都是单个单词的。
