1. mvc和mvvm
mvc是模型-视图-控制器 控制器负责将model的数据展示在view
mvvm是模型-视图-视图模型 实现了数据的双向绑定，通过数据绑定将模型转化为视图，通过DOM事件监听实现了视图转换为模型
mvc和mvvm最大的区别就是：实现了view和model的自动同步，当model改变时候，不需要再自己手动操作dom来改变view的显示，而是自动改变，简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用使用选择器操作DOM元素。

2. vue为什么说没有完全遵循mvvm思想呢？
严格的mvvm要求view和model不能直接通信，而vue提供了$refs这个属性，让model可以直接操作view，这违反了这一规定，所以说vue没有完全遵循mvvm

3. vue组件中中data为什么是一个函数
data(){
    return {
        count: 0
    }
}
data: function () {
  return {
    count: 0
  }
}
组件中的data写成一个函数，数据以函数值形式定义，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，让每个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份data，就会影响其他组件的结果

3. vue组件通讯有哪几种方式
 - props和$emit 父组件向子组件传递数据是通过prop传递的，子组件传递数据给父组件是通过$emit触发事件来做到的
 - $parent,$children获取当前组件的父组件和当前组件的子组件
 - $attrs和$listeners A->B->C
 $attrs 包含了父作用域中不作为prop被识别的attribute绑定（class和style除外），当一个组件没有声明任何prop时，这里会包含所有父作用域的绑定，并且可以通过v-bind="$attrs"传入到内部组件——在创建高级别的组件时非常有用

 $listeners包含了父作用域中不含.native修饰器的v-on事件监听器，它可以通过v-on="$listeners" 传入内部组件，在创建更高层次的组件时非常有用

 - 父组件中通过provide来提供变量，然后在子组件中通过inject来注入变量（官方不推荐在实际业务中使用，但是写组件库时很常用）
 - $refs获取组件实例
 - eventBus 兄弟组件传递数据，这种情况下可以使用事件总线的方式
 - vuex状态管理

4. vue的生命周期方法有哪些？一般在哪一步发请求
  - beforeCreate 在实例初始化之后，数据观测（data observer）和event、watcher事件配置之前被调用。当前阶段data、methods、computed以及watch上的数据和方法都不能被访问
  - created 实例已经被创建完成之后调用。在这一步，实例已完成以下的配置：数据观测（data observer），属性和方法的运算，watch/event事件回调，这里没有$el，如果非要与DOM进行交互，可以通过vm.$nextTick来访问DOM
  - beforeMount在挂载开始之前被调用：相关的render函数首次被调用， **服务端渲染期间不可被调用**
  - mounted 在挂载完成后发生，在当前阶段，真实的DOM挂载完毕，数据完成双向绑定，可以访问到DOM节点，**服务端渲染期间不可被调用**
  - beforeUpdate 数据更新时调用，发生在虚拟DOM重新渲染和打补丁（patch）之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程，**服务端渲染期间不可被调用，因为只有初次渲染会在服务端进行**
  - updated 发生在更新完成之后，当前阶段组件DOM已完成更新，要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新，该钩子**在服务端渲染期间不被调用**
  **update不会保证所有的子组件也都一起被重绘，如果你希望等到整个视图都重绘完毕，可以在update里使用vm.$nextTick**
  - beforeDestroy 实例销毁之前调用，在这一步，实例仍然完全可用。我们可以在这时进行善后收尾工作，比如清除定时器 **在服务端渲染期间不被调用**
  - destroyed vue实例销毁后调用。调用后，vue实例指示的所有东西都会被解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁，**在服务端渲染期间不被调用**
  - activated 被keep-alive缓存的组件被激活时调用 **在服务端渲染期间不被调用**
  - deactivated 被keep-alive缓存的组件被销毁时调用 **在服务端渲染期间不被调用**
  - errorCaptured 
  当捕获一个来自子孙组件的错误时被调用，此钩子会接收三个参数：错误对象、发生错误的组件实例，以及一个包含错误来源信息的字符串，此钩子可以返回false以阻止该错误继续向上传播
  你可以在此钩子中修改组件的状态，因此在捕获错误时，在模板或渲染函数中有一个条件判断绕过其它内容就很重要，不然该组件可能会进入一个无限的渲染循环


  异步请求在哪一步发起
  可以在created、beforeMount、mounted中进行异步请求，因为在这三个钩子函数中，data已经创建，可以将服务端返回的数据进行赋值
  如果异步请求不依赖DOM,推荐created
  1. 能更快获取到服务端数据，减少页面loading时间
  2. ssr不支持beforeMount、mounted钩子函数，放在created中有助于一致性


5. v-if和v-show的区别
v-if在编译过程中会被转化成三元表达式，条件不满足不渲染此节点
v-show 会编译成指令，条件不满足时控制样式将对应节点隐藏
v-show不支持template元素
v-if是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和创建
v-if也是惰性的：如果在初次渲染时条件为假，则什么都不做一直到条件第一次变为真时，才会开始渲染条件块
v-show不管初始条件是什么，元素总是会被渲染，而且只是简单地基于css进行切换
一般来说，v-if有更高的切换开销，而v-show有更高的初始渲染开销，因此，如果需要非常频繁的切换用v-show，如果在运行时条件很少改变，用v-if较好

- 扩充： display:none;visibility:hidden;和opacity:0之间的区别
三者共同点都是隐藏
不同点：
一、是否占据空间 display:none隐藏之后不占位置 visbility:hidden、opacity:0隐藏后仍然占据位置
二、子元素是否继承
display:none 不会被子元素继承，但是父元素不存在了，子元素也不会显示出
visibility:hidden 会被子元素继承，通过设置子元素visibility:visible来显示子元素
opacity:0 会被子元素继承,但是子元素设置opacity:1 不显示

三、事件绑定
display:none，元素已经不存在页面，无法触发它绑定的事件
visibility:hidden 不会触发它上面的事件
opacity:0 上面绑定的事件是可以触发的

四、过渡动画
transition对于display是无效的
transition对于visibility是无效的
transition对于opacity是有效的


6. vue内置指令

v-once 定义它的元素或组件只渲染一次，包括元素或组件的所有子节点，首次渲染后，不再跟随数据的变化重新渲染，将被视为静态内容

v-cloak 这个指令保持在元素上直到关联实例结束编译——解决初始化慢导致页面闪动的最佳实践，和css规则如：
[v-cloak] {
  display: none;
}
<div v-cloak>
  {{ message }}
</div>
不会显示，直到编译结束

v-bind 绑定属性，动态更新html元素上的属性，如v-bind:class = :bind

v-on   用于监听DOM事件，例如：v-on:click v-on:keyup 缩写@

v-html 赋值变量的innerHTML 注意防止xss攻击

v-text 更新元素的textContent

v-model value和input事件的语法糖 并且会处理

v-if/v-else/v-else-if  可以配合template来使用，在render函数里面就是三元表达式

v-show 使用指令来实现显示隐藏

v-for 循环指令 优先级比v-if高 最好不要一起使用，尽量使用计算属性去解决，注意增加唯一的key值，不要使用index作为key
v-for支持遍历对象，第二个参数是键名

v-pre 跳过这个元素以及子元素的编译过程，以此来加快整个下项目的编译速度

7. 怎样理解vue的单向数据流
数据总是父组件到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止子组件意外改变父组件的状态，从而导致你的应用的数据流难以理解。
注意：子组件直接用v-model绑定父组件传过来的prop这样是不规范的 开发环境会报警告
子组件不能在内部更改父组件传过来的prop
（1）如果子组件希望接下来将其作为一个本地的数据使用，最好定义一个本地的data，并将这个prop作为其初始值
（2）这个prop以一种原始的值传入且需要进行转化，这种情况下最好使用这个prop值来定义一个计算属性

对于对象或数组类型的prop来说，在子组件中改变或变更这个对象或数组本身将会影响到父组件的状态

8. computed和watch的区别和运用的场景
computed是计算属性，依赖其他属性计算值，而且computed的值有缓存，只有当计算值变化时才会返回内容，它可以设置getter和setter
watch监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作
计算属性一般用于模板渲染中，某个值是依赖了其他的响应式对象甚至是计算属性计算而来，而侦听器属性适用于观测某个值的变化去完成一段复杂的业务逻辑


计算属性缓存和方法：


 computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
  // 在组件中
methods: {
  reversedMessage: function () {
    return this.message.split('').reverse().join('')
  }
}

计算属性是基于它们的响应式依赖进行缓存的，只有依赖的值发生改变时才会重新计算求值，这意味着只要message还没有改变，多次访问reversedMessage，计算属性会立即返回之前的计算结果而不必再次执行函数
computed: {
  now: function () {
    return Date.now()
  }
} // 这里计算属性将不再更新，因为Date.now不是响应式依赖

相比之下，每当触发重新渲染时，调用方法总会再次执行函数


计算属性和侦听属性
计算属性默认只有getter，不过在需要时你也可以提供一个setter
computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}

**计算属性是deep的响应，即在计算过程中用到的对象的属性发生变化是可以被监听到的**
**watch的默认响应是非deep的响应，可以设置deep来实现deep响应**

9. v-if与v-for为什么不建议一起使用
v-for和v-if不要在一个标签中使用，因为解析时，先解析v-for再解析v-if，如果遇到需要同时使用时，可以考虑写成计算属性的方式
<li v-for="todo in todos" v-if="!todo.isComplete">
  {{ todo }}
</li>
这意味着v-if将分别重复运行于每个v-for循环中

### todo

10. vue2.0响应式数据的原理 整体思路是数据劫持+观察者模式 ！！！
对象内部通过defineReactive方法，使用Object.defineProperty将属性进行劫持（只会劫持已经存在的属性），数组则是通过重写数组方法来实现，当页面使用对应属性时，每个属性都拥有自己的dep属性，存放他所依赖的watcher(依赖收集)，当当属性变化后会通知自己对应的watcher去更新
class Observer {
  // 观测值
  constructor(value) {
    this.walk(value);
  }
  walk(data){
    // 对象上的属性依次进行观测
    let keys = Object.keys(data);
    for(let i = 0; i < keys.length; i++){
      let key = keys[i];
       let value = data[key];
      defineReactive(data, key, value);
    }
  }
}
// Object.defineProperty数据劫持核心 兼容性在ie9以及以上
function defineReactive(data, key, value) {
  observe(data)
  // --如果value还是一个对象会继续走一遍odefineReactive 层层遍历一直到value不是对象才停止
  //   思考？如果Vue数据嵌套层级过深 >>性能会受影响
  Object.defineProperty(data, key, {
    get() {
      console.log("获取值");

      //需要做依赖收集过程 这里代码没写出来
      return value;
    },
    set(newValue) {
      if (newValue === value) return;
      console.log("设置值");
      //需要做派发更新过程 这里代码没写出来
      value = newValue;
    },
  });
}

}

11. vue如何检测数组变化
数组考虑性能原因没有用defineProperty对数组的每一项进行拦截，而是选择对7种数组（push pop shift unshift reverse splice sort ）方法进行重写
所以在vue中修改数组的索引和长度是无法监控到的，需要通过以上7种变异方法修改数组才能触发数组对应的watcher进行更新
12. vue3.0用过吗 了解多少
响应式原理的改变：vue3使用proxy取代vue2的Object.defineProperty
组件选项声明方式vue3使用Composition API

composition API 将零散分布的逻辑组合在一起来维护，并且还可以将单独的功能逻辑拆分成单独的文件
- setup: 是组件内使用composition API的入口
setup的执行时机：beforeCreate之前





