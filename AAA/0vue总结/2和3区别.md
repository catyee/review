# 数据劫持
1. 递归 
Object.defineProperty(object,key,{
    get() {},
    set() {}
})
Object.defineProperty(obj, prop, descriptor)给对象上定义一个新属性，或修改一个对象的现有属性，并返回此对象。

descriptor：属性描述符

属性描述符两种： 数据描述符，存取描述符，不能同时是两者

两者共享的可选键值： configurable:false   enumerable:false   

数据描述符： value:undefined  writable:false  

存取描述符：get,set

Object.defineProperties(obj, {
  'property1': {
    value: true,
    writable: true
  },
  'property2': {
    value: 'Hello',
    writable: false
  }
  // etc. etc.
});

- **vue2劫持数据采用defineProperty，会把对象循环给每个属性增加getter，setter**
无法监听对象的新增属性，删除属性，无法监听数组方法的操作，数组length的修改，索引设置数组
需要递归key对应的value(如果value是引用属性)
数组需要劫持方法来单独处理


- **vue3采用proxy不需要去改写属性getter，setter，不需要完全递归，取到某一层递归**

# 模板编译优化
- vue2优化：判断是不是静态节点，如果静态节点不去dom diff
- 编译时生成block tree，对子节点动态节点收集，减少比较，采用了patchFlag标记动态节点
# compositionApi 避免了在配置项里反复横跳，优化复用逻辑（mixin带来的数据来源不清晰，命名冲突），类型推断更加方便
# 增加了Fragment（多根节点），teleport，suspense组件

# ref（将一个普通类型，转换成一个对象，这个对象有value属性，指向原来的值）和reactive（） toRef（解构reacttive 解构某一个 将一个对象的属性变成ref） toRefs 响应式解构 name.value )

reactive内部用proxy ref内部用proxy

# effect中所有的属性都会收集effect，当这个属性发生变化会重新执行effect