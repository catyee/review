- Vue.extend        html/css js   es6+ ts  node，http  项目 webpack 模块化
- 插槽
- 异步组件
- 组件渲染更新过程
- 父子组件生命周期
- Vue.mixin
- keep-alive原理
-  vue组件 只有一个根元素？
- 使用vue可以做哪些优化
- scope样式？element 样式覆盖及原理
- vue-router原理

1. Vue.extend实现
Vue.extend的作用是创建一个子类，所以可以创建一个子类，然后让它继承Vue身上的一些功能。

创建一个子类，将父类的原型继承到子类中，将父类的options选项继承到子类中


2. 路由懒加载（按需加载）
路由懒加载或按需加载是一种很好的优化网页或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离，然后在一些代码块中完成某些操作之后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始化加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载。
组件先在路由里注册但不进行组件的加载与执行，等到需要访问组件的时候才进行真正的加载。

vue异步组件的原理：
在使用到该组件时，异步通过请求去拉取对应组件的js（需要webpack和import相结合）。当对应的js加载完成后，获取到异步组件的配置项，从而创建组件构造器，再通过forceRender强制依赖它的vm实例重新触发渲染函数。

在vue中，如果多个vm实例都用到了异步组件，异步组件只会加载一次并在内存中做缓存，不会重复加载。

3. 组件的渲染和更新过程
    1. 项目编译时, .vue中的template会被vue-loader编译成render函数，并添加到组件选项对象里。组件通过components引用该组件选项，创建组件（vue实例），渲染页面（组件被多次引用时，引用的是相同的组件选项），main.js根组件template转化成render函数是由vue插件中的编译器实现的。
    2. 组件渲染页面时，会先调用render函数，render函数返回组件内标签节点（vnode实例），每个标签都会创建一个节点。
    3. 如果标签是组件标签，通过components获取到组件选项，使用extend方法生成组件的构造函数，并将构造函数和组件选项保存在组件标签节点上。
    4. render函数生成组件内标签节点，并设置根节点的parent指向组件节点。将节点作为新节点传入到patch方法中，组件页面初始更新时，不存在旧节点，直接根据新节点创建DOM
    5. 在patch方法中，根据节点创建DOM，并在节点上保存它的dom引用，再根据节点的children值，创建子节点的dom，再添加到父节点的dom中，完成组件的渲染。
    6. 在根据节点创建DOM的过程中，如果节点包含组件构造器信息，或先创建构造器创建组件，调用组件的render方法，执行以上操作。
4. 组件data为何必须为函数
vue每次通过组件创建构造函数，每个实例都是通过这个构造函数来进行实例化，如果是一个对象的话会公用同一个引用，会相互影响。
5. vue事件绑定的原理
- 原生的事件绑定 采用addEventListener实现 
- 组件 $on 发布订阅模式   native.on 采用addEventListener

6. v-model
组件：默认value+input
自定义model属性 {prop: 'checkbox',event:'change'}

原生：value + input + 输入法处理指令

7. v-html会导致哪些问题
    - 可能会导致xss攻击
    - v-html会替换掉标签内部的子元素

8. Vue相同逻辑如何抽离
Vue.mixin 核心mergeOptions 将当前定义的属性合并到每个组件中
可以全局使用 可以组件内使用

生命周期如何合并： 创建一个数组，mixin放入数组前面

9. 为什么要使用异步组件

分开打包，而且采用jsonp方式进行加载
import语法实现组件的分割


10. 插槽和作用域插槽
插槽： 创建组件vnode的时候，会将组件的儿子虚拟节点保存起来。当初始化组件时，通过插槽属性将儿子进行分类。渲染组件时会拿对应的slot属性的节点进行替换操作。（插槽的作用域为父组件）

作用域插槽： 作用域是子组件

作用域插槽的内容会被渲染成一个函数。

vue组件实例化顺序为：父组件状态初始化(data、computed、watch...) --> 模板编译 --> 生成render方法 --> 实例化渲染watcher --> 调用render方法，生成VNode --> patch VNode，转换为真实DOM --> 实例化子组件 --> ......重复相同的流程 --> 子组件生成的真实DOM挂载到父组件生成的真实DOM上，挂载到页面中 --> 移除旧节点


11. keep-alive 缓存
include（需要缓存） exclude（不缓存） active deactive

LRU算法  最近最久未使用

12. vue组件 只有一个根元素？
    1. 实例化Vue时， new Vue(el:'#app') vue不能确定入口，如果有多个根元素
    2. 单文件组件：
    <template>
        <div>

        </div>
    </template>
    也是一个vue实例，无法确定入口
    3. diff算法要求

13. vue scope原理 scope样式？element 样式覆盖及原理

scoped给dom增加唯一属性 选择器后增加这个属性 
如果组件内部还有组件，只会给最外层的组件的标签加上唯一属性字段，不影响组件内部引用的组件

慎用原因：
可达到样式作用域的效果。但是如果组件中也引用其他组件就会出现问题：
1. 父组件无scoped属性，子组件有scoped属性，父组件无法操作子组件样式，
2. 父组件有scoped属性，子组件无，父组件无法设置子组件样式，因为父组件都带有一个唯一标识，但子组件没有标识
3. 父子都有scoped属性，都无法互相设置


样式穿透：深度选择器
vue中的scoped属性的主要效果是通过postcss转译实现
通过 外层 >>> 第三方组件{样式} 可以穿透scoped，修改其他组件的值

stylus使用>>>

less/sass /deep/

修改第三方组件的样式：
1. 样式穿透
2. 定义一个不含scoped的全局样式 在里面修改