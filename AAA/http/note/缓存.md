# 缓存分为很多种：DNS缓存，数据库缓存，代理服务器缓存，浏览器缓存
# 1. http缓存即浏览器缓存 分为强缓存和协商缓存

**浏览器缓存是将用户请求过的静态资源（html，css，js）存储到电脑本地磁盘中，当浏览器再次访问时，直接从本地价值了，不需要再去服务器请求了**


**浏览器有一个专门存放缓存规则的映射表，把缓存资源信息同电脑磁盘中实际文件地址对应**

浏览器对于缓存的处理是根据第一次请求资源时返回的 **响应头**来确定的。
浏览器每次发起请求，都会先在浏览器缓存中查找该请求的缓存结果和缓存标识
浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入到浏览器缓存中

## 基本原理
1. 浏览器在加载资源的时候，会根据请求头的expires和cache-control去浏览器缓存中查找，判断是否名中强缓存，如果是强缓存，则直接从缓存中读取资源，不会发送请求到服务器

2. 如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过last-modified和etag 验证资源是否命中协商缓存，如果命中（即资源没有更新），服务器会将这个请求返回，但是不会返回这个资源的数据，依然从缓存中读取数据

3. 如果两者都没有命中，直接从服务器加载资源


## 强缓存实现
1. 强缓存通过expires和cache-control响应头实现（服务器返回）
2. expires是http1.0提出的一个表示资源过期时间的header，是一个绝对时间，服务器返回，但是受限于本地时间，如果修改了本地时间，会造成缓存失效

3. cache-control出现在http1.1，优先级高于expires，是一个相对时间cache-control:max-age=3153600000

4. cache-control: no-cache 会缓存
   cache-control: no-store 不缓存数据到本地
   cache-control: public 可以被所有用户缓存（多用户共享），包括终端和CDN等中间代理服务器
   cache-control: private 只能被终端浏览器缓存（而且是私有缓存），不允许中继缓存服务器进行缓存


## 协商缓存实现

**每次http请求都会在response header中返回etag和 last-modified**
**在下次请求的时候request header会把这两个值带上（但是名字变成了 etag ——> if-none-matched  last-modified ——> if-modified-since）,服务端将你发过来的标示同资源目前的标示做对比，判断资源是否更改，这个过程是循环往复的，即缓存表在每次请求成功后都会更新规则。**


1. 当浏览器对某个资源的请求没有命中强缓存，就会发送一个请求到服务器，验证协商缓存是否命中，**如果协商缓存命中，请求响应返回的状态码为304**并且会显示一个not modified的字符串

2. 协商缓存利用的是last-modified，if-modified-since 和etag，if-none-match 这两对header来管理的

3. last-modified和if-modified-since

 - last-modified表示本地文件最后的修改日期，浏览器会在request header 加上if-modified-since（上次返回的last-modified的值），询问服务器在该日期后资源是否有更新，有更新的话会将新的资源发送回来
 但是如果在本地打开资源文件，就会造成last-modified文件被修改


 - ETag 和 if-none-match
    1. ETag就像一个指纹，资源变化都会导致ETag变化，ETag可以保证每一个资源都是唯一的
    2. If-None-Match的header会将上次返回的ETag发送给服务器，询问资源的ETag是否有更新，有变化jiu h 发送新的资源回来
    3. ETag的优先级比last-modified优先级更高


## 几种状态码的区别
1. 200强缓存 expires和cache-control失效时，返回新的资源文件
2. 200（form-cache）强缓存Expires和cache-control两者都存在且未过期，Cache-Control优先Expires时，浏览器从本地获取资源成功

3. 304（not modified）协商缓存last-modified/ETag没有过期，服务端返回304

协商缓存需要配合强缓存使用，如果不启用强缓存的话，协商缓存根本没有意义  

## 如果什么缓存策略都没设置，那么浏览器会怎么处理
对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的date减去last-modified值的10%作为缓存时间