# 0.TCP和UDP协议 都是传输层
## UDP 
用户数据报协议，是一个简单的**面向数据报的通信协议**，不提供可靠性，只是把应用程序传给IP层的数据报发送出去，但是不能保证他们到达目的地。由于UDP在传输数据报之前不在客户和服务器之间建立一个连接，且没有超时重发机制，故而传输速度很快。

特点如下：

- UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务
- 传输途中出现丢包，UDP 也不负责重发
- 当包的到达顺序出现乱序时，UDP没有纠正的功能。
- 并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为

无连接，不会拆分重组，只负责加标示头然后发送，接收端只是去除报文头然后传递给上层
不止支持一对一传输，同样支持一对多，多对多，多对一，提供了单播，多播，广播的功能
面向保温
不可靠，尽最大努力交付



## TCP
传输控制协议，是一种可靠的，**面向字节流的通信协议**，把上层交下来的数据看成无结构的字节流来发送

必须建立TCP连接，之后才能传输数据，提供超时重发，丢弃重复数据，校验数据，流量控制等功能，保证数据能从一端到另一端

会根据网络的拥塞状态来确定每个报文段的大小

TCP首部较大，额外开销大

特点如下：

- TCP充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。
- 此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。
- 根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）

## 区别
TCP 保证可靠性，必须建立连接，面向字节流，效率低，全双工，滑动窗口流量控制，拥塞控制
UDP 不可靠，面向报文，传输效率高，一对一，一对多，多对多 没有流量控制 拥塞控制 比较快

## 应用场景
SMTP 电子邮件：TCP
TELNET 远程终端接入：TCP
HTTP 万维网：TCP
FTP 文件传输：TCP



DNS 域名转换：UDP
TFTP 文件传输：UDP
SNMP 网络管理：UDP
NFS 远程文件服务器：UDP


TCP适用于效率要求低准确性要求高或要求有连接的场景
UDP适用于效率要求高，准确性要求低

****************************************************************************************************



# TCP是面向连接的，可靠的，基于字节流的传输层通信协议，在发送数据之前，通信双方必须在彼此间建立一条连接。 连接本质上是客户端和服务端保存的一份关于对方的信息，比如ip地址，端口号等


TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题，在建立连接的过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。

一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：连接、数据传输、退出（关闭）。通过三次握手建立一个链接，通过四次挥手来关闭一个连接。

# 当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。

# 1. tcp 三次握手和四次挥手？为什么？

## 是什么？

- 第一次握手（SYN,Seq = x）
客户端发送SYN报文，服务端收到就能得出结论：客户端的发送和服务端的接收是正常的

第二次握手：
服务端发送SYN和ACK，客户端收到了就表示服务端的接收和发送以及客户端的接收和发送是正常的，但是此时服务端不知道客户端的接收是正常的

第三次握手：
客户端发送ACK报文，服务端接收后就知道客户端的发送和接收都是正常的，服务端自身的接收和发送都是正常的


通过三次握手，可以确认双方的发送和接收都是正常的，就可以正常通信了



## 为什么必须三次握手，而不是两次

如果是两次握手，发送端能确认自己发送的对方能收到，也能确认对方发送和接收没问题，但接收端不能确认自己发的包对方能收到

客户端如果因为网络阻塞，发送多个请求，延时的请求到达服务端之后，又会建立连接，但此时客户端早已关闭连接，因此会造成服务器资源的浪费





# 四次挥手
tcp终止一个连接，需要四次挥手

- 第一次挥手：客户端发送一个FIN报文，报文中会指定一个序列号，此时客户端处于FIN_WAIT1状态，停止发送数据，等待服务端确认
- 第二次挥手：服务端收到客户端FIN，会发送ACK确认，表明已经收到客户端的报文了，此时服务端处于CLOSE_WAIT状态
- 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发送FIN报文，此时服务端处于LAST_ACK的状态
- 第四次挥手：客户端收到FIN之后，一样发送一个ACK应答，此时客户端处于TIME_WAIT状态，需要过一阵子以确保服务端收到自己的ACK报文之后才进入CLOSED状态，服务端收到ACK报文之后就处于关闭连接了，处于CLOSED状态

客户端在经过2MSL一段时间后，自动进入close状态，至此客户端也完成连接的关闭

## 四次挥手的原因

服务端在收到客户端断开连接Fin报文后，并不会立即关闭连接，而是先发送一个ACK包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送FIN报文断开连接，因此需要四次挥手



# 为什么 TIME_WAIT 等待的时间是 2MSL?

MSL是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

等待MSL两倍：网络中可能存在发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。

2MSL的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 2MSL 时间将重新计时。



















# 2. tcp滑动窗口

# 4. tcp如何保证有效传输以及拥塞控制原理

