# es6模块和commonjs

## es6写法：
es6模块默认采用严格模式

### 导出
export const name = 'a'
或
const name = 'a'
export {name}
或export {name as myName} // 导入时候为myName


#### export.default
理解为对外输出了一个名为default的变量
export default 'string'
export default class
export default {
    name:'',
    add: ''
}


### 导入
import {name} from './a'
加载命名导出的模块，import后面要加{}

import * as a from './a' // 整体导入
a.add()
a.name

默认导出的，导入的时候import直接跟变量名，名字可以任意指定

### 导入导出复合写法 只支持命名导出的，不支持默认导出
export {name} from './a.js'


















## commonjs写法：
### 导出：
module.exports = {
    name: '',
    func: function() {}
}

exports.a = ''

**commonjs模块内部会有一个module对象用于存放当前模块的信息，可以理解为在每个模块的最开始定义了以下对象**
var module = {}
module.exports = {} // 用来指定该模块要对外暴露哪些内容

为了书写方便，commonjs支持另一种简化的导出：**exports.add = function() {}**

**实现效果上，exports.name = '' 和module.exports.name = ''没有什么区别，其内在机制是将exports指向了module.exports**

var module = {}
var exports = module.exports

#### 使用exports导出需要注意：
不能exports = {} 直接进行赋值操作，这样会导致指向新的对象，本质上不再是使用module.exports导出了

#### 导出的语句不代表模块的末尾，导出语句后面仍旧可以指向代码比如console，但是建议导出语句module.exports放在结尾
import语句会执行所加载的模块，因此可以有下面的写法。
import 'lodash';
import 'lodash';
import 'lodash';
上面代码加载了两次lodash，但是只会执行一次。


### commonjs导入

### 写法：
使用require导入
const a = require('./a')
a.add(1,2) // 导入了a模块，并调用了add函数

**当我们require一个模块的时候会有两种情况：**
- require模块是第一次被加载，这时会首先执行该模块，然后导出内容
- require模块曾被加载过，这时该模块的代码不会被再次执行，而是直接导出上次执行后得到的结果（module对象有一个属性loaded记录是否被加载过）

### 加载模块不需要获取其内容，而只是想执行？
require('./a')

### require可以接收表达式，因此可以动态指定路径
const name = a
require('/'+name)









### 是否存在变量提升
 - es6 存在变量提升 import命令具有提升效果，会提升到整个模块的头部，首先执行
 - commonjs不存在变量提升

### 动态和静态
commonjs：动态的，模块依赖关系的建立是发生在代码运行阶段
es6：静态的，模块依赖关系的建立发生在代码编译阶段
es6不支持导入的路径是一个表达式，且导入导出的语句都必须放在顶层作用域（比如不能if）
es6编译阶段就可以分析出模块的依赖关系

es6静态的优势：
无用代码检测排除
模块变量类型检查
编译器优化（不是整个导入对象，而是直接导入变量或函数，减少了层级引用）

### 值拷贝与动态映射
导入模块时：
commonjs导入的是导出值的拷贝，允许导入的值进行修改，不会影响导出模块本身
es6是值的动态映射，并且值是只读的


### 循环依赖
循环依赖指的是模块A依赖于模块B，同时模块B依赖于模块A

es6导入的值是动态映射，利用这一个特性可以更好的支持循环依赖，只要保证导入的值被使用时已经设置好正确的导入值
commonjs导入的是值的拷贝，不会随着模块中原有值的改变而改变

# require 会将完整的 exports 对象引入，import 可以只 import 部分必要的内容，


ES6 模块规范和 commonjs 规范 运行机制的区别
CommonJS 模块是运行时加载，ES6 模块是编译时输出接口

运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。

编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。

CommonJS 加载的是一个对象(即module.exports属性)，该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。



## 循环依赖的不同处理

CommonJS模块是加载时执行。一旦出现某个模块被“循环加载”，就只输出已经执行的部分，没有执行的部分不会输出。

ES6模块对导出模块，变量，对象是动态引用，遇到模块加载命令import时不会去执行模块，只是生成一个指向被加载模块的引用。