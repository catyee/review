webpack打包后：
最外层立即执行匿名函数，包裹整个bundle
每个模块第一次加载被存储到一个对象，installedModules，再次加载的时候直接从里面取值
所有产生依赖关系的模块存储在modules对象


context：资源入口的路径前缀，目的是让entry更加简洁，必须使用绝对路径
提取vendor，将vendor缓存

output.path指定资源输出的位置，值必须为绝对路径

publicPath 指定资源的请求位置（js或css所请求的间接资源路径）

webpack中publicPath指定webpack-dev-server的静态资源服务路径

## loader预处理器 本质是一个函数，与loader相关的配置都在module对象中

css-loader处理css的各种加载语法 style-loader将样式插入到页面
webpack打包loader处理是从数组的后面到前面开始
['style-loader','css-loader']
loader可以配置exclude和include

html-loader将html转化成字符串并进行格式化
file-loader 打包文件类型的资源 图片使用
url-loader 类似file-loader但是可以设置文件大小阈值
vue-loader拆分组件模板js及样式


## 自定义loader
// force-strict0loader
module.exports = function(content) {
    if(this.cacheable) {
        this.cacheable()
    }
    var useStrictPrefix = '\'use strict \';\n\n'
    return useStrictPrefix + content
}

### source-map 便于实际开发者在浏览器控制台查看源码

## plugins配置 接收一个插件数组（插件包括webpack内部提供的插件，也可以加载外部插件

## 样式提取是以资源入口开始的整个chunk（一组有依赖关系的模块的封装）为单位的

### postcss 增加前缀 postcss配置autoprefixer
### styllint css质量检测工具
### cssnext允许使用最新的css特性



### cdd modules css模块化 有单独作用域轻松复用其他css

css-loader开启modules:true



### code splitting 代码分片 
进行代码拆分，让用户不必一次全部加载，而是按需加载


# 异步加载
webpack异步加载import() require.ensure()
import()返回一个Promise对象

import()可以在任何作用域调用，比如if

注释让webpack获取异步资源的名字
import(/*webpackChunkName:"bar"*/)


# 为本地和生产添加不同的环境变量
DefinePlugin

# sourceMap便于调试，只有打开浏览器开发者工具才会加载 .map文件
js在webpack文件中设置devtools:sourceMap，可以看到源码

css,scss,less等也需要单独设置

hide-source-map避免安全问题，不能看到map文件

# 压缩代码 uglifyjs，terser(面向未来，支持es6+)

