# 1. webpack优化
1. 代码分片，提取公共引入
2. 开启source-map 便于追踪调试
3. 资源压缩
4. 利用hash缓存 chunk内容生成hash作为版本号，并添加到资源文件名中，使资源更新后理解被客户端获取到
5. bundle体积监控分析，webpack-bundle-analyzer，bundlesize

打包优化
1. happypack多线程打包
2. 缩小打包作用域 exclude include noParse
3. 利用cache，有些loader有cache选项
4. 利用tree-shaking (只对es6 module生效，babel-loader解析的时候webpack收到的是转化后的commonjs模块，所以必须禁用它的模块依赖解析)
5. 使用压缩工具 去除死代码

6. speed-measure-webpack-plugin 分析webpack在整个打包过程中在各个loader和plugin上耗费的时间
size-plugin 监控资源体积的变化



# 2. webpack的理解？解决了什么问题？
实现了模块化，能够支持更高级的特性，监听文件的变化反应到浏览器，除了js其他如css，html等也实现了模块化，更好的实现了代码的压缩合并优化

# 3. webpack的构建流程
webpack运行流程是串行的过程，工作流程就是将各个插件串联起来

识别入口文件

逐层识别模块依赖
分析代码，转换代码，编译代码，输出代码
形成打包后的代码


# 4. webpack中的loader是什么？解决了什么问题？
loader本质是一个函数 用于对模块的源代码进行转换，在import或加载模块时预处理文件

默认情况下，在遇到import或require加载模块的时候，webpack只支持对js或json文件打包，
像css，sass，png等这些类型的文件的时候，webpack则无能为力，这时候就需要配置对应的loader进行文件内容的解析

webpack遇到不识别的模块，去配置中查找该文件的解析规则 module.rules配置

loader的特性：支持链式操作

常见的loader:

style-loader 将css添加到DOM内联样式标签style里面
css-loader 允许将css require方式引入
sass-loader 处理sass
postcss-loader 结合 autoprefixer 增加css前缀
file-loader
babel-loader:babel转换es6


# 5. plugin

plugin赋予各种灵活的功能，例如打包优化，资源管理，环境变量注入等，运行在webpack的不同阶段（钩子/生命周期），贯穿webpack整个编译周期
整个编译周期生命周期钩子：
初始化option
run
compile 真正开始编译
compilation:生成了compilation对象
after-compile编译build过程结束
。。。

常见的plugins
htmlwebpackplugin 自动生成一个html文件，并把打包的js模块引入到该html中

mini-css-extract-plugin 提取css到一个单独的文件

 

 # 6. loader和plugin的区别，编写二者的思路？
 
 ## 区别：
 - loader是文件加载器，能够加载资源文件，并对这些文件进行一些处理，例如编译转换，压缩等，最终一起打包到指定的文件中
是一个转换器，对A文件进行编译成B文件，文件转换

loader运行在打包文件之前

 - plugin赋予了webpack灵活的功能，例如打包优化，资源管理，环境变量注入，目的是解决loader无法实现的其他事情
 基于事件机制工作，监听webpack打包过程中的某些节点，执行广泛的任务

plugin对整个编译周期都起作用



## 编写loader
loader本质是一个函数，接收webpack传递给loader的源内容，函数中的this是webpack提供的对象，能够获取当前loader所需的各种信息

## 编写plugin
webpack运行过程中有很多事件，插件监听这些事件，在特定的阶段执行自己的插件任务

插件必须是一个对象或者是一个包含apply方法的对象

- compiler：包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和 webpack 整个生命周期相关的钩子
- compilation：作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation 将被创建


# 7. webpack的热更新是如何做到的，原理是什么
HMR,模块热替换，指在应用程序运行过程中，替换，添加删除模块，而无需重新刷新整个应用

devServer 指定hot:true  需要指定哪些模块热更新


## 实现原理
webpack-dev-server创建两个服务器，一个提供静态资源服务，一个socket服务
socket服务是一个websoket长连接，双方可以通信，监听到对应的模块发生变化，会生成两个文件.json(manifest文件)和.js(update chunk)
通过长连接，socket server可以直接将这两个文件主动发送给客户端
浏览器拿到两个新的文件后，通过热更新机制，加载这两个文件，并且针对修改的模块进行更新


# 8. webpack proxy工作原理，为什么能解决跨域
webpack配置devserver proxy 可以解决跨域

## 工作原理
实质上是利用http-proxy-middleware 这个http代理中间件，实现请求转发给其他服务器

webpack-dev-server会启动一个本地开发服务器，我们的应用开发阶段独立运行在localhost的一个端口上，而后端服务运行在另一个地址上，此时会出现跨域的问题

通过webpack proxy实现代理请求后，相当于浏览器与服务端中添加一个代理者，当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据相应给本地。

代理服务器与服务器之间不会存在跨域行为，跨域行为存在浏览器上


# 9.webpack优化前端
- js代码压缩
- css代码压缩
- html代码压缩
- 文件大小压缩
- 图片压缩
- tree-shaking

    optimization:{
        usedExports
    }
- 代码分离 按需加载代码
1. 代码分片，提取公共引入
2. 开启source-map 便于追踪调试
3. 资源压缩
4. 利用hash缓存 chunk内容生成hash作为版本号，并添加到资源文件名中，使资源更新后理解被客户端获取到
5. bundle体积监控分析，webpack-bundle-analyzer，bundlesize


rollup不适合开发插件，不支持热更新，需要配合第三方模块

vite作用类似于webpack+webpack-dev-server 快速冷启动，即时模块更新，真正按需编译