
# 1. 判断相等二叉树
function isSameTree(tree1,tree2) {
    if(tree1 === null && tree2 === null) {
        return true
    }
    if(tree1 === null || tree2 === null) {
        return false
    }
    if(tree1.val !== tree2.val) {
        return false
    }
    return isSameTree(tree1.left,tree2.left) && isSameTree(tree1.right,tree2.right)
}

# 2. js实现双向链表
双向链表：每个节点包含三部分：指向前一个节点的指针， 指向后一个节点的指针， 以及自己的数据部分
## 双向链表介绍
既可以从头遍历到尾，也可以从尾遍历到头，链表连接的过程是双向的，实现原理是一个节点既有向前连接的引用，也有向后连接的引用

## 双向链表的缺点
- 每次在插入或删除某个节点时，都需要处理四个引用，而不是两个，实现起来困难些
- 相对于单链表，所占内存空间更大
- 但是便利性更强，所以缺点微不足道

## 双向链表的结构

- 双向链表不仅有head指针指向前一个节点，而且有tail指针指向最后一个节点
- 每一个节点都有三部分：item储存数据，prev指向前一个节点，next指向后一个节点
- 双向链表第一个节点的prev指向null
- 双向链表的最后一个节点的next指向null


## 双向链表的常见方法
- append(element)： 向链表尾部添加一个新的项
- insert(position,element):向链表的指定位置插入一个新的项
- get(element): 获取对应位置的元素
- indexOf（element）：返回元素在链表中的索引，如果链表中没有元素就返回-1；
- update（position，element）：修改某个位置的元素；
- removeAt（position）：从链表的特定位置移除一项；
- isEmpty（）：如果链表中不包含任何元素，返回true，如果链表长度大于0则返回false；
- size（）：返回链表包含的元素个数，与数组的length属性类似；
- toString（）：由于链表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值；
- forwardString（）：返回正向遍历节点字符串形式；
- backwordString（）：返回反向遍历的节点的字符串形式；



function Node(element) {
    this.element = element;
    this.next = null
    this.previous = null
}

class Node {
    constructor(data) {
        this.data = data
        this.next = null
        this.previous = null
    }
}

class DoubleLinked {
    constructor() {
        this.size = 0
        this.head = new Node('head')
        this.currentNode = ''
    }
    // 获取链表长度
    getSize() {
        return this.size
    }
    // 判断链表是否为空
    isEmpty() {
        return this.size === 0
    }
    // 显示当前节点
    showNode() {
        return this.currentNode.data
    }
    // 正序遍历

    displayList() {
        let str = ''
        let currentNode = this.head  // 打印结果带head值
        // var currentNode=this.head.next  打印结果不带head值
        while(currentNode) {
            str += currentNode.data
            currentNode = currentNode.next
            if(currentNode) {
                str += '——>'
            }
        }
        return str
    }

    // 倒序遍历
    lastDisplay() {
        let str = ''
        let currentNode = this.findLast()
        while(currentNode) {
            str += currenNode.data
            currentNode = currentNode.prev
            if(currentNode) {
                str += '——>'
            }
        }
        return str
    }

    // 获取最后一个元素
    findLast() {
        let currentNode = this.head
        while(currenNode.next) {
            currentNode = currenNode.next
        }
        return currentNode
    }

    // 查找某一个元素
    findNode(data) {
        let currenNode = this.head
        while(currentNode && currentNode.data === data) {
            currentNode = currentNode.next
        }
        return currentNode
    }

    // 在头部插入一个节点
    headAppend(data) {
        let newNode = new Node(data)
        newNode.next = this.head.next
        this.head.next.prev = newNode
        newNode.prev = this.head
        this.head.next = newNode
        this.size ++
    }

    // 在尾部插入一个节点
    append(data) {
        let newNode = new Node(data)
        let currentNode = this.finalLast()
        currentNode.next = newNode
        newNode.next = null
        newNode.prev = currentNode
        this.size ++
    }
    // 插入节点 表示将element值插入到data值之后
    insertNextNode(data,element) {
        let currentNode = this.findNode(data)
          //如果data不存在
        if (!currentNode) {
            return
        }
        let newNode = new Node(element)
        newNode.next = currentNode.next
        currentNode.next.prev = newNode
        currentNode.next = newNode
        newNode.prev = currentNode
        this.size++
       
    }

    // 插入节点 表示将element插入到data值之前
    insertPrevNode(data,element) {
        let currentNode = this.findNode(data)
        if(!currentNode) {
            return
        }
        let newNode = new Node(element)
        newNode.next = currentNode
        currentNode.prev.next = newNode
        newNode.prev = currentNode.prev
        currentNode.prev = newNode
        this.size ++
    }

    // 删除一个节点
    deleteNode(data) {
        let currentNode = this.findNode(data)
        // 删除的是最后一个节点
        if(currentNode.next === null) {
            currentNode.prev.next = null
        }else {
            currentNode.prev.next = currentNode.next
            currentNode.next.prev = currentNode.prev
        }
        this.size--
    }
}




# 3.手写题：在线编程，getUrlParams(url,key); 就是很简单的获取url的某个参数的问题，但要考虑边界情况，多个返回值等等


# 4.数据库的分类

# 5.数组的去重
# 6. 数组的扁平化处理

# 7.「字节」实现字符串驼峰转换
# 8.「字节」比较两个版本号大小
# 9.「腾讯」根据对象ID实现数组去重
# 10.「字节」基于JS实现按照权重抽奖
# 11.「阿里」实现斐波那契数列fibonacci

# 12.实现开方

# 13. 最小操作 bfs
# 14. 所有可能 dfs
# 15. 数组 双指针