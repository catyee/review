# 1. display:none、visibility:hidden 和 opacity:0 之间的区别？
三者共同点都是隐藏
不同点：
一、是否占据空间 display:none隐藏之后不占位置 visibility:hidden、opacity:0隐藏后仍然占据位置
二、子元素是否继承
display:none 不会被子元素继承，但是父元素不存在了，子元素也不会显示出
visibility:hidden 会被子元素继承，通过设置子元素visibility:visible来显示子元素
opacity:0 会被子元素继承,但是子元素设置opacity:1 不显示

三、事件绑定
display:none，元素已经不存在页面，无法触发它绑定的事件
visibility:hidden 不会触发它上面的事件
opacity:0 上面绑定的事件是可以触发的

四、过渡动画
transition对于display是无效的
transition对于visibility是无效的
transition对于opacity是有效的

# **visibility,opacity 不会引起回流,只会引起重绘
display会引起重绘和回流**


# 2. html5的新特性
 - <!DOCTYPE>
 声明位于文档中的最前面的位置，在<html>标签之前
 不是一个html标签，告知web浏览器页面使用了哪种html版本
 - 更好的语义化标签 （合理的标签做合理的事情）
 header，footer，article nav section artical
 - 音频视频标签 audio video
 - 表单控件 color date datetime email number tel url week
 - localStorage，sessionStorage
 - 画布/canvas
 - 地理/Geolocation 允许用户向web应用程序提供他们的位置
 - 拖拽释放 使应用程序能够在浏览器中使用拖放功能
 - web workers 当html在页面中执行脚本时，页面的状态是不可响应的，直到脚本已经完成，web worker是运行在后台的js，独立于其他脚本，不会影响页面的性能，可以继续做其他事情如点击，选取，而此时web worker在后台运行。

 3. <!DOCTYPE>的作用
 用来告诉浏览器要使用什么样的文档类型定义来解析文档。
 <!DOCTYPE>声明是用来指示web浏览器关于页面使用哪个HTML版本进行编写的指令。
 浏览器本身分为两种模式，一种是标准模式，一种是怪异模式，浏览器通过doctype来区分这两种模式，doctype在html中的作用就是触发浏览器的标准模式，如果html中省略了doctype，浏览器就会进入到Quirks模式的怪异状态，在这种模式下，有些样式会和标准模式存在差异，而html标准和dom标准值规定了标准模式下的行为，没有对怪异模式做出规定，因此不同浏览器在怪异模式下的处理也是不同的，所以一定要在html开头使用doctype。

 4. css link引入和@import引入

 link是html的标签，不但可以加载css文件，还可以定义RSS,ref连接属性等
 @import是css的语法，只有导入样式表的作用

 加载顺序：
 link会和html同时被加载
 @import会在页面加载完毕后加载

 S可操作link引入的样式而不能操作@import引入的样式


 link和@import的权重

 没有明确的权重关系，只是link引入的样式某些情况下会覆盖掉@import的样式

 按说@import是页面加载完之后才加载的，应该是后覆盖的，但是..
 浏览器执行过程：加载（url解析，发请求，接收资源） ——>  解析(将加载到的资源进行语法解析，构建DOM树，js对象属性表，css样式规则等) ——> 渲染(构造渲染树 对各个元素进行位置计算、样式计算，然后根据渲染树完成页面的布局及绘制)

 实际上，浏览器的渲染动作一般是执行多次的。最后一次渲染一定是基于之前加载过的所有样式整合后生成的渲染树进行渲染的，已经被渲染过的页面元素也会被重新渲染。
 那么我们就可以把@import这种引入css文件的方式理解成一种替换，css解析引擎在对一个css文件进行解析时，如在文件顶部遇到@import，将被替换为该@import导入的css文件中的全部样式。
 @import虽然后被加载，但是加载完毕后会被放在样式表顶部，最终渲染时自如会被下面的同名样式层叠。


 # 5. 浏览器多个标签页之间的通信
 注释： 浏览器多个标签页通信：在浏览器打开多个窗口，在其中一个窗口做了一些行为，其他窗口不用刷新也能有相关表现。

    - 1. cookie + setInterval方式：
    将共享信息存储进cookie，定期取出

    缺点：cookie空间有限，最多每个域名下30-50个cookie，最多4k左右，每次http会把cookie内容发送到服务器， setInterval频率过大影响浏览器性能，过小影响时效性。
    优点： 每个浏览器都兼容


    - 2. localStorage方式
    localStorage在setItem存取的时候会触发整个浏览器的storage事件，除了当前页面，所有打开的窗口都可以受到影响。
    缺点： ie8以上，兼容性，不同浏览器大小不一致，只能监听非自己的页面的数据变化。

    有点：方便


    - 3. websoket方式
    websoket方式需要用到服务器，send页面发送消息到websocketServer，websokectServer再把实时消息发送给receive页面，实现实时通信。
    缺点：需要服务端支持
    优点：使用简单，更灵活强大

    - 4. sharedWorker方式


# 6. 行内元素 块级元素 空元素（标签内没有内容的元素被称为空元素）
空元素: <br> 
行内元素：i span a等
多个标签存在一行，不能直接设置宽高，上下margin设置不起作用，左右margin可以设置，padding可以设置,左右padding没有问题，上下padding会有padding的边距效果，但是如果上面有一个元素，会覆盖上面的元素。

块级元素： 独占一行，不设置宽度的话，宽度默认100%，margin，padding都可以设置

行内块级元素：input img 行内显示，可以设置margin padding  宽高

三类标签转换
    行内元素： display: inline
    块级元素：display:block
    行内块级元素：display: inline-block

# 7. src与href的区别
src是替换当前元素 比如<script src="js.js">,指向外部资源的位置，指向的内容会嵌入到文档中当前标签所在的位置，在请求src资源的时候，会将其指向的资源下载并应用到文档内。比如js脚本，img图片，和frame等元素。
当浏览器解析到src的元素时，会暂停其他资源的下载和处理，直到该资源加载、编译、执行完毕，图片框架等元素也是如此，类似于将资源嵌入到当前标签内，这也是为什么js资源放在底部而不是头部。

href指向网络资源所在的位置，建立和当前元素(锚点)或当前文档(链接)之间的链接，如果我们在文档中添加
<link href="common.css" rel="stylesheet"/>
那么浏览器会识别该文件为css文件，就会并行下载资源而不会停止对当前文档的处理（解析不会暂停，渲染可能会暂停，因为浏览器需要样式表的样式来绘制页面）。这也就是为什么会用link加载css而不是@import 

src会将资源嵌入到当前文档中，href会建立一个关联指向资源就像<a href="https://www.baidu.com"></a>并不会将百度嵌入到当前页面中，而<iframe src="https://www.baidu.com"></iframe>就会）。


src会阻塞页面吗？

src引用的外部资源不会阻塞页面
是否阻塞跟是不是src或href没有关系，跟浏览器实现最佳体验的设计有关系。例如打开淘宝网，可以看到图片是最后渲染出来的，因为图片通常比较大，如果阻塞的话会造成白屏，体验不好。js被设计成阻塞，原因是因为它可能会改变DOM树或cssom树

浏览器渲染过程：
1. 输入url发送请求
2. 加载html文件
3. 加载完解析html，会在解析的过程中构建DOM树和cssom树
解析遇到link script img标签时，浏览器会向服务器发送请求资源
script的加载或执行都会阻塞html解析、其他下载线程以及渲染线程
link加载完会解析生成cssom树，css的加载和解析不会阻塞html的解析，但是会阻塞渲染。
4. css说的cssom树会和dom树结合生成render tree 渲染树
5. layout 计算出render树每个节点的具体位置
6. painting 通过显卡，将layout后的节点内容呈现到屏幕上


js的defer和async属性

script  会阻塞

浏览器在解析html的时候，如果遇到一个没有任何属性的script标签就会暂停解析，先发送网络请求获取该js脚本的代码内容，然后让js引擎执行该代码，当代码执行完毕后恢复解析html。

async script

async表示异步 可能阻塞也可能不阻塞
当浏览器遇到带async属性的script时，请求该脚本的网络请求是异步的，不会阻塞浏览器解析html，一旦网络请求回来之后，如果此时html还没有解析完，浏览器会暂停解析，js引擎执行代码，执行完之后再进行解析

如果js脚本请求回来之后，html已经解析完毕了，那么直接执行js代码。
所以async是不可控的，因为执行时间不确定，如果在js异步脚本中获取某个DOM元素，有可能获取到也有可能获取不到。如果存在多个async，他们之间的执行顺序也不确定，完全取决于网络传输结果，谁先到先执行谁。



defer script 不阻塞

defer表示延迟
当浏览器遇到带有defer属性的script时，获取该脚本的网络请求也是异步的，不会阻塞浏览器解析html，一旦网络请求回来之后，如果此时html还没有解析完，浏览器不会暂停解析，而是等html解析完成后执行js代码

如果存在多个defer script标签，浏览器ie9以下除外，会保证他们按照在html中出现的顺序执行，不会破坏js脚本之间的依赖关系。

# 8. cookies，sessionStorage，localStorage的区别
cookie
cookie是网站为了标示用户信息而存在本地终端上的数据，可以设置过期时间，如果没有设置，浏览器关闭会删除
一般是服务器生成
前端设置：document.cookie
数据存储大小有限制，不同浏览器有差别，一般是4k
每次请求都会在同源的http请求中携带（放在请求header里面）
cookie的domain和path两个属性可以限制cookie能被哪些url访问及cookie何时被添加到请求头发送出去。domain的默认值是该cookie的网页所在的域名，path默认值是设置该cookie的网页所在的目录


localStorage
1. 基本操作：设置 localStorage.name = '1'/localStorage.setItem('name', '1') 获取：localStorage.getItem('name') / localStorage.name
2. 除非被清理 否则一直存在
3. 受同源策略影响 同一浏览器的相同域名和端口的不同页面间可以共享共同的localStorage

sessionStorage
用法同localStorage
页面关闭就清理
只有同一个会话的页面才能访问，当前会话结束也随之销毁，即使同源页面之间也无法共享，如果一个页面包含多个iframe且它们属于同源页面 则它们之间是可以共享的

indexDB
除非被清理，否则一直存在

# 9.service worker 离线存储

# 10. 怎么处理移动端1px被渲染成2px的问题
为何出现：
UIS设计稿是物理像素，css代码是css像素
设备像素比：物理像素/css像素
写代码的时候需要将UI设计稿的物理像素转化为css像素
UI给的设计稿是1px(物理像素)我们需要转化为css像素就是0.5px

有的浏览器在解析0.5px的时候，最小像素为1px，会把它解析为1px，所以最终呈现的效果在手机上会是2px(物理像素) 看起来变粗了

解决：
1. 当写0.5px的时候，会显示一个物理像素宽度的border，而不是一个css像素的border，所以在ios下可以写：
border:0.5px solid #999;
缺点：安卓不兼容

2. 设置宽度为1px，配合scale缩放

3. 使用viewport-initial-scale 将整个页面缩放为0.5，然后写1px即可展示1px的边框
优点：可以直接写1px 兼容性好
缺点：会让页面整体缩小，如果是老项目，需要全部更改css样式

4. svg svg是矢量图形，它的1px对应的物理像素就是1px
@svg border_1px { 
  height: 2px; 
  @rect { 
    fill: var(--color, black); 
    width: 100%; 
    height: 50%; 
    } 
  } 
.svg { border: 1px solid transparent; border-image: svg(border_1px param(--color #00b1ff)) 2 2 stretch; }

可以搭配 PostCSS 的 postcss-write-svg 使用：

# 11. 浏览器是如何渲染页面的 https://www.jianshu.com/p/e6252dc9be32
要了解浏览器渲染页面的过程，首先要知道一个名词——关键渲染路径，关键渲染路径是指浏览器从最初接收请求来的html、css、javascript等资源，然后解析、构建树、渲染布局、绘制，最后呈现给用户能看到的界面这整个过程。
用户看到页面实际上可以分为两个阶段：页面内容加载完成和页面资源加载完成分别对应于DOMContentLoaded和Load
- DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表、图片等
- load事件触发时，页面上所有的DOM,样式表、脚本、图片都已经加载完成

浏览器渲染主要有五步
1. 浏览器将获取的html解析成DOM树
2. 处理css标记，构成层叠样式模型CSSOM(CSS Object Model)
3. 将DOM树和CSSOM树合并为渲染树(rendering tree) 代表一系列将被渲染的对象
4. 渲染树每个元素包含的内容都是计算过的，它被称为布局layout。浏览器通过使用一种流式处理的方法只需要一次绘制操作就可以布局所有的元素。
5. 将渲染树的各个节点绘制到屏幕上

上述五个步骤不是一次性顺序完成，
比如DOM或CSSOM被修改时，亦或是哪个过程会重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。而在实际情况中，JavaScript和CSS的某些操作往往会多次修改DOM或者CSSOM。

- 构建DOM树：
当浏览器接收到服务器响应来的HTML文档后，会遍历文档节点，生成DOM树。
需要注意以下几点：

DOM树在构建的过程中可能会被CSS和JS的加载而执行阻塞
display:none的元素也会在DOM树中
注释也会在DOM树中
script标签会在DOM树中

- 构建CSSOM规则树
css解析可以和DOM解析同时进行
css解析与script 

- 构建渲染树
通过DOM树和CSS规则树，浏览器就可以通过它两构建渲染树了。浏览器会先从DOM树的根节点开始遍历每个可见节点，然后对每个可见节点找到适配的CSS样式规则并应用。
有以下几点需要注意：
- Render Tree和DOM Tree不完全对应
- display: none的元素不在Render Tree中
- visibility: hidden的元素在Render Tree中
渲染树生成后，还是没有办法渲染到屏幕上，渲染到屏幕需要得到各个节点的位置信息，这就需要布局（Layout）的处理了。

- 渲染树布局(layout of the render tree)
布局阶段会从渲染树的根节点开始遍历，由于渲染树的每个节点都是一个Render Object对象，包含宽高，位置，背景色等样式信息。所以浏览器就可以通过这些样式信息来确定每个节点对象在页面上的确切大小和位置，布局阶段的输出就是我们常说的盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。需要注意的是：

float元素，absoulte元素，fixed元素会发生位置偏移。
我们常说的脱离文档流，其实就是脱离Render Tree。

- 渲染树绘制
在绘制阶段，浏览器会遍历渲染树，调用渲染器的paint()方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的。

css阻塞渲染树生成
div p {font-size: 16px}，会先寻找所有p标签并判断它的父标签是否为div之后才会决定要不要采用这个样式进行渲染）。


# 回流(reflow) / 重排  和重绘(repaint)
回流：
当浏览器发现布局发生了改变，需要倒回去重新渲染，这个回退的过程叫reflow，refloww会从html开始递归向下，依次计算所有结点几何尺寸和位置，以确认是渲染树的一部分发送变化还是整个渲染树。

重绘repaint
改变背景色，文字颜色等不影响它周围或内部布局的属性时

display:none会触发回流reflow

visibility:hidden仍然占据位置，只会触发repaint 重绘

现代浏览器会对回流做优化，它会等到足够数量的变化发生，再做一次批处理回流。
引发回流：
页面第一次渲染（初始化）
DOM树变化（如：增删节点）
Render树变化（如：padding改变）
浏览器窗口resize
获取元素的某些属性

回流一定引起重绘

重绘：背景色、颜色、字体改变（注意：字体大小发生变化时，会触发回流）

减少reflow和repaint的次数
- 避免逐个修改节点样式，尽量一次性修改
- 用transform做形变和位移可以减少reflow
- 可以将需要多次修改的DOM元素设置display:none，操作完再显示。（因为隐藏元素不在render树内，因此修改隐藏元素不会触发回流重绘）
- 避免多次读取某些属性
- 通过绝对位移将复杂的节点元素脱离文档流，形成新的Render Layer，降低回流成本

优化渲染效率：
- 样式文件放在head里面，脚本文件放在body结束前
- 简化css选择器，减少嵌套层
- DOM的多个操作放在一起
- 尽量使用文档碎片document.fragment，操作完之后将这个对象加入到DOM
- position为absolute或fixed的元素，重排的开销会小一些，因为不用考虑对其他元素的影响
- 用window.requestAnimationFrame()、window.requestIdleCallback()这两个方法调节重新渲染。

# 12.iframe的优缺点
- iframe会阻塞主页面的onload事件
- iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以影响页面的并行加载
- 为了避免以上问题，可以使用js代码动态给iframe添加src属性，这样可以避免以上两个问题

# 13.canvas和svg的区别
canvas通过js来绘制图像，绘制完成后，浏览器不再关注，如果位置变换，需要重新绘制
svg使用xml来描述2d图像
svg是一种矢量图，放大不会失真，而canvas放大会失真
svg支持事件处理器，canvas不支持事件处理器，canvas只能给整个画布添加事件而不能给某个图形或文件添加事件处理器，但是svg支持事件绑定

# 14.meta标签
提供给页面一些元信息（名称/ 值对）
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

- 设置网站编码
<meta charset="UTF-8">
<meta http-equiv="Content-Type"content="text/html;charset=UTF-8">

- 设置视口的缩放
常见取值:
width：控制viewport的宽度，这个值可以被指定，例如：500px。亦或者是“device-width”，意思是设置视口宽度为设备宽度。
height：控制viewport的高度。
initial-scale：初始缩放比例，即每一次加载时页面缩放的比例。
maximum-scale：允许用户缩放到的最大缩放比例。
minimum-scale：允许用户缩放到的最小缩放比例。
user-scaleable：是否允许用户缩放，可以传“yes”或“no”
<meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scaleable=no">



- 设置网站关键字
<meta name="keywords" content="关键字1，关键字2" />

- 设置网站描述
<meta name="description" content="这里写描述" />

<!-- http-equiv -->

- 设置ie兼容模式
<meta http-equiv="X-UA-Compatible" content="IE=7">
以上代码告诉IE浏览器，IE8/9及以后的版本都会以最高版本IE来渲染页面

- 设置页面自动跳转或刷新
<meta http-equiv="refresh" content="3; url=http://www.baidu.com">

注意: 3表示页面跳转间隔时间,url表示页面跳转的新网页地址

- content-type
如果使用这个属性，其值必须是"text/html; charset=utf-8"。注意：该属性只能用于MIME type为 text/html 的文档，不能用于MIME类型为XML的文档。
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">


- expires 用于设置网页缓存过期时间
1. 加长缓存期，减少从服务器请求：时间必须使用GMT格式. 如果你想要一个GMT时间
<meta http-equiv="expires" content="Sunday 26 October 2020 03:00 GMT" />

2. 禁止缓存
    <META HTTP-EQUIV="Pragma" CONTENT="no-cache"> 
    <META HTTP-EQUIV="Cache-Control" CONTENT="no-cache"> 
    <META HTTP-EQUIV="Expires" CONTENT="0">

- pragma 定义页面缓存
 < meta http-equiv="cache-control" content="no-cache" >,
