1. mvvm和mvc
- mvc model view controller 数据变化通过controller去改变视图，视图变化是依赖模型的
- mvvm 视图变化通过视图模型更新数据，数据绑定到视图模型，自动渲染到页面上，视图模型和视图双向绑定

2. vue2.0响应式数据的原理
- vue在初始化数据的时候，会给data中的属性使用Object.defineProperty重新定义所有的属性，会进行依赖收集（收集当前组件的watcher），如果属性发生变化会通知相关依赖进行更新操作。


3. vue如何检测数组变化
- 使用函数劫持的方法，重写了数组的方法
- vue将data中的数组进行了原型链的重写，指向了自己定义的数组原型方法，这样当调用数组api时，可以通知依赖更新，如果数组中包含着引用类型会对数组中的引用类型进行再次监控

4. 为何vue采用异步渲染
因为如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能考虑，vue会在本轮数据更新后，再去异步更新视图

5. nextTick实现原理
nextTick方法主要是使用了宏任务和微任务定义了一个异步方法，多次调用nextTick会将方法存入到队列中，通过这个异步方法清空当前队列，所以这个nextTick方法就是异步方法。

6. vue中computed的特点
默认computed也是一个watcher是具备缓存的，只有当依赖的属性发生变化时才会重新求值更新视图

7. watch中的deep：true是如何实现的
当用户指定了watch中的deep属性为true时，会对对象中的每一项进行求值，此时会将当前watcher存入到对应属性的依赖中，这样数组中对象发生变化时也会通知数据更新。

8. vue组件的生命周期
- beforeCreate 在实例初始化之后，数据观测之前被调用
- created 实例已经创建完成之后被调用，在这一步，实例已经完成以下配置：数据观测，属性和方法的计算，watch event事件回调，这里没有$el
- beforeMount在挂载开始之前被调用，相关的render函数首次被调用。服务端渲染期间不可被调用
- mounted el被创建的vm.$el替换，并挂载到实例上去之后调用该钩子，服务端渲染期间不可被调用
- beforeUpdate 数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前，这里适合在更新之前访问所有的DOM，比如手动移除已经添加的事件监听器。服务端渲染期间不可被调用
- updated由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子，服务端渲染期间不可被调用
- activated 被keep-alive缓存的组件激活时调用，该钩子在服务端渲染期间不可被调用
- deactivated 被keep-alive缓存的组件停用时调用，该钩子在服务端渲染期间不可被调用
- beforeDestroy实例销毁之前调用，在这一步实例依然完全可用，该钩子在服务端渲染期间不可被调用
- destroyed vue实例被销毁之后调用，调用后，vue实例指示的所有东西都会解绑定，所有的事件监听器都会被移除，所有的子实例也会被销毁，该钩子在服务端渲染期间不可被调用

9. ajax请求放在哪个生命周期中
created和mounted都可以，服务端渲染不支持mounted

10. 何时需要使用beforeDestroy
- 在当前页面中使用了$on方法，需要在组件销毁前解绑
- 清除自己定义的定时器
- 解除事件的绑定 scroll mousemove...

11. vue中模板编译原理
- 将template转化成render函数

12. vue中v-if和v-show的区别
- v-if如果条件不成立不会渲染当前指令所在节点的DOM元素
- v-show只是切换当前dom显示或隐藏

13. 为什么v-if和v-for不能连用
v-for会比v-if的优先级高一些，如果连用的话会把v-if给每个元素都添加一下，会造成性能问题

14. 用vnode来描述一个DOM结构
虚拟节点就是用一个对象来描述真实的dom元素

15. diff算法的时间复杂度
两个树的完全的diff算法是一个时间复杂度为o(n3)

16. 简述vue中diff算法的原理
1. 先同级比较，再比较子节点
2. 先判断一方有儿子一方没儿子的情况
3. 比较都有儿子的情况
4. 递归比较子节点
