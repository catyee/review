<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>
    var s = new Set()
    var arr = [2, 3, 5, 4, 5, 2, 2]
    arr.map(x => s.add(x))
    console.log([...s], 666)
    for (let i of s) {
        console.log(i);
    }
    var set = new Set([1, 2, 2, 2, 3, 4, 5])
    console.log([...set])

    // set 类似于精确相等运算符 === 主要区别是NaN等于自身，而 === NaN不等于自身
    // add(value)：添加某个值，返回Set结构本身。
    // delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
    // has(value)：返回一个布尔值，表示该值是否为Set的成员。
    // clear()：清除所有成员，没有返回值。


    // weakSet结构与Set类似，也是不重复的值的集合，但是它与set有两个区别
    // 首先WeakSet的成员只能是对象而不能是其他类型的值
    // 其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的
    // var ws = new WeakSet();
    // ws.add(1)
    // TypeError: Invalid value used in weak set
    //  ws.add(Symbol())
    // TypeError: invalid value used in weak set
    var a = [[1, 2], [3, 4]];
    var ws = new WeakSet(a);
    console.log(ws, 'wwwwwwwwwwwwwwwww')
    // 上面代码中，a是一个数组，它有两个成员，也都是数组。将a作为WeakSet构造函数的参数，a的成员会自动成为WeakSet的成员。
    // var b = [3, 4];
    // var ws = new WeakSet(b);
    // Uncaught TypeError: Invalid value used in weak set(…)
    // 上面代码中，数组b的成员不是对象，加入WeaKSet就会报错。
//     WeakSet结构有以下三个方法。

// WeakSet.prototype.add(value)：向WeakSet实例添加一个新成员。
// WeakSet.prototype.delete(value)：清除WeakSet实例的指定成员。
// WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在WeakSet实例之中。
// WeakSet没有size属性，没有办法遍历它的成员。

// ws.size // undefined
// ws.forEach // undefined

// ws.forEach(function(item){ console.log('WeakSet has ' + item)})
// TypeError: undefined is not a function
// WeakSet不能遍历，因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。
// WeakSet的一个用处就是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏
// 下面是WeakSet的另一个例子。

// const foos = new WeakSet()
// class Foo {
//   constructor() {
//     foos.add(this)
//   }
//   method () {
//     if (!foos.has(this)) {
//       throw new TypeError('Foo.prototype.method 只能在Foo的实例上调用！');
//     }
//   }
// }
// 上面代码保证了Foo的实例方法，只能在Foo的实例上调用。这里使用WeakSet的好处是，foos对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑foos，也不会出现内存泄漏。















// map
// js中的对象本质上是键值对的集合，但是传统只能用字符串当作键，这给它的使用带来了很大的限制
var data = {}
var element = document.getElementById('myDiv')
data[element] = 'metadata'
data['[object HTMLDivElement]'] // "metadata"
// 上面代码原意是将一个DOM节点作为对象data的键，但是由于对象只接受字符串作为键名，所以element被自动转为字符串[object HTMLDivElement]。

// 为了解决这个问题，es6提供了Map的数据结构，它类似于对象，也是键值对的集合，但是键的范围不限于字符串，各种类型的值包括对象都可以当作键，也就是说，Object提供了字符串——值的对应，Map结构提供值——值的对应，是一种更完善的Hash结构实现，如果你需要键值对的数据结构，Map比Object更合适
var m = new Map();
var o = {p: 'Hello World'};

m.set(o, 'content')
m.get(o) // "content"

m.has(o) // true
m.delete(o) // true
m.has(o) // false

// 作为构造函数，Map也可以接收一个数组作为参数。该数组的成员是一个个表示键值对的数组
var map = new Map([
  ['name', '张三'],
  ['title', 'Author']
]);
map.size // 2
map.has('name') // true
map.get('name') // "张三"
map.has('title') // true
map.get('title') // "Author"

// WeakMap
// WeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。


var a = [1,2,2,2,1,3,4,6,6,7,7,8]
var set = new Set(a)
var c = [...new Set([1,2,2,2,1,3,4,6,6,7,7,8])]
console.log(c, 'setsetset')


// Set的参数 类数组或数组 不能添加重复 的值 可以用来数组去重 可以set.add()增加值，set加入值不会进行类型转换
// Set的操作方法： add delete has clear 
// Set的遍历方法 let item of set.keys()     let item of set.values()    let item of set.entries()    set.forEach
// Set扩展运算符转换为数组 然后使用数组方法


// WeakSet的成员只能是对象，WeakMap中的对象是弱引用 参数可以是数组或类数组，数组的成员是WeakSet实例的成员，成员必须为对象，因此数组的成员只能是对象
// 操作方法： add delete has 无法遍历



// Map 接受数组作为参数 数组的成员是一个个表示键值对的数组
var map = new Map([
  ['name', '张三'],
  ['title', 'Author']
]);
// 操作方法：set get
</script>

</html>